<!DOCTYPE html><html lang="zh-TW" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>Java面試知識點 | King's Backyard</title><meta name="author" content="HongZiXian"><meta name="copyright" content="HongZiXian"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="本文內容來自牛客网中校招冲刺集訓的Java工程師課程:https:&#x2F;&#x2F;www.nowcoder.com&#x2F;courses&#x2F;cover&#x2F;live&#x2F;689   1 Java基础1.1 为什么Java代码可以实现一次编写、到处运行？JVM（Java虚拟机）是Java跨平台的关键。在程序运行前，Java源代码（.java）需要经过编译器编译成字节码（.class）。在程序运行时，JVM负责将字节码翻译成特定">
<meta property="og:type" content="article">
<meta property="og:title" content="Java面試知識點">
<meta property="og:url" content="https://www.hongzixian.cn/2023/02/27/Java%E9%9D%A2%E8%A9%A6%E7%9F%A5%E8%AD%98%E9%BB%9E/index.html">
<meta property="og:site_name" content="King&#39;s Backyard">
<meta property="og:description" content="本文內容來自牛客网中校招冲刺集訓的Java工程師課程:https:&#x2F;&#x2F;www.nowcoder.com&#x2F;courses&#x2F;cover&#x2F;live&#x2F;689   1 Java基础1.1 为什么Java代码可以实现一次编写、到处运行？JVM（Java虚拟机）是Java跨平台的关键。在程序运行前，Java源代码（.java）需要经过编译器编译成字节码（.class）。在程序运行时，JVM负责将字节码翻译成特定">
<meta property="og:locale" content="zh_TW">
<meta property="og:image" content="https://s2.loli.net/2023/02/26/VZb4gMHaKpovYEf.png">
<meta property="article:published_time" content="2023-02-27T04:46:31.000Z">
<meta property="article:modified_time" content="2023-03-04T12:45:41.421Z">
<meta property="article:author" content="HongZiXian">
<meta property="article:tag" content="Spring">
<meta property="article:tag" content="服務端">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://s2.loli.net/2023/02/26/VZb4gMHaKpovYEf.png"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://www.hongzixian.cn/2023/02/27/Java%E9%9D%A2%E8%A9%A6%E7%9F%A5%E8%AD%98%E9%BB%9E/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="/css/font.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"languages":{"hits_empty":"找不到您查詢的內容：${query}"}},
  translate: {"defaultEncoding":1,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":200},
  copy: {
    success: '複製成功',
    error: '複製錯誤',
    noSupport: '瀏覽器不支援'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '剛剛',
    min: '分鐘前',
    hour: '小時前',
    day: '天前',
    month: '個月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Java面試知識點',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-03-04 20:45:41'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/custom.css" media="defer" onload="this.media='all'"><link rel="stylesheet" href="/css/progress_bar.css"><!-- hexo injector head_end start --><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-categories-card@1.0.0/lib/categorybar.css"><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-wowjs/lib/animate.min.css" media="print" onload="this.media='screen'"><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-tag-plugins-plus@latest/lib/assets/font-awesome-animation.min.css" media="defer" onload="this.media='all'"><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-tag-plugins-plus@1.0.17/lib/tag_plugins.css" media="defer" onload="this.media='all'"><script src="https://npm.elemecdn.com/hexo-butterfly-tag-plugins-plus@latest/lib/assets/carousel-touch.js"></script><!-- hexo injector head_end end --><meta name="generator" content="Hexo 6.3.0"></head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">載入中...</div></div></div><script>const preloader = {
  endLoading: () => {
    document.body.style.overflow = 'auto';
    document.getElementById('loading-box').classList.add("loaded")
  },
  initLoading: () => {
    document.body.style.overflow = '';
    document.getElementById('loading-box').classList.remove("loaded")

  }
}
window.addEventListener('load',()=> { preloader.endLoading() })

if (true) {
  document.addEventListener('pjax:send', () => { preloader.initLoading() })
  document.addEventListener('pjax:complete', () => { preloader.endLoading() })
}</script><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://s2.loli.net/2022/11/22/gqkpnz3Prte8RQU.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">22</div></a><a href="/tags/"><div class="headline">標籤</div><div class="length-num">23</div></a><a href="/categories/"><div class="headline">分類</div><div class="length-num">6</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首頁</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 文檔</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 標簽</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分類</span></a></div><div class="menus_item"><a class="site-page group hide" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 清單</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音樂</span></a></li><li><a class="site-page child" href="/Gallery/"><i class="fa-fw fas fa-images"></i><span> 圖片</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 影片</span></a></li><li><a class="site-page child" href="/ETD/"><i class="fa-fw fas fa-light fa-heart"></i><span> 心電</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友鏈</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 關於</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://s2.loli.net/2023/02/26/skohyb8aJQMduKF.png')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">King's Backyard</a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首頁</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 文檔</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 標簽</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分類</span></a></div><div class="menus_item"><a class="site-page group hide" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 清單</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音樂</span></a></li><li><a class="site-page child" href="/Gallery/"><i class="fa-fw fas fa-images"></i><span> 圖片</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 影片</span></a></li><li><a class="site-page child" href="/ETD/"><i class="fa-fw fas fa-light fa-heart"></i><span> 心電</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友鏈</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 關於</span></a></div></div><div id="nav-right"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜尋</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">Java面試知識點</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">發表於</span><time class="post-meta-date-created" datetime="2023-02-27T04:46:31.000Z" title="發表於 2023-02-27 12:46:31">2023-02-27</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新於</span><time class="post-meta-date-updated" datetime="2023-03-04T12:45:41.421Z" title="更新於 2023-03-04 20:45:41">2023-03-04</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E6%9C%8D%E5%8B%99%E7%AB%AF%E9%96%8B%E7%99%BC/">服務端開發</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字數總計:</span><span class="word-count">16.2k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">閱讀時長:</span><span>49分鐘</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="Java面試知識點"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">閱讀量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><div class="note info flat"><p>本文內容來自牛客网中校招冲刺集訓的Java工程師課程:<a target="_blank" rel="noopener" href="https://www.nowcoder.com/courses/cover/live/689">https://www.nowcoder.com/courses/cover/live/689</a> </p>
</div>
<h2 id="1-Java基础"><a href="#1-Java基础" class="headerlink" title="1 Java基础"></a>1 Java基础</h2><h3 id="1-1-为什么Java代码可以实现一次编写、到处运行？"><a href="#1-1-为什么Java代码可以实现一次编写、到处运行？" class="headerlink" title="1.1 为什么Java代码可以实现一次编写、到处运行？"></a>1.1 为什么Java代码可以实现一次编写、到处运行？</h3><p>JVM（Java虚拟机）是Java跨平台的关键。<br>在程序运行前，Java源代码（.java）需要经过编译器编译成字节码（.class）。在程序运行时，JVM负责将字节码翻译成特定平台下的机器码并运行，也就是说，只要在不同的平台上安装对应的JVM，就可以运行字节码文件。<br>同一份Java源代码在不同的平台上运行，它不需要做任何的改变，并且只需要编译一次。而编译好的字节码，是通过JVM这个中间的“桥梁”实现跨平台的，JVM是与平台相关的软件，它能将统一的字节码翻译成该平台的机器码。</p>
<h3 id="1-2-一个Java文件里可以有多个类吗-不含内部类"><a href="#1-2-一个Java文件里可以有多个类吗-不含内部类" class="headerlink" title="1.2 一个Java文件里可以有多个类吗(不含内部类)?"></a>1.2 一个Java文件里可以有多个类吗(不含内部类)?</h3><p>一个java文件里可以有多个类，但最多只能有一个被public修饰的类；<br>如果这个java文件中包含public修饰的类，则这个类的名称必须和java文件名一致。</p>
<h3 id="1-3-说一说你对Java访问权限的了解"><a href="#1-3-说一说你对Java访问权限的了解" class="headerlink" title="1.3 说一说你对Java访问权限的了解"></a>1.3 说一说你对Java访问权限的了解</h3><p>Java语言为我们提供了三种访问修饰符，即private、protected、public，在使用这些修饰符修饰目标时，一共可以形成四种访问权限，即private、defalut、protected、public，注意在不加任何修饰符时为defalut访问权限。</p>
<p>在修饰成员变量/成员方法时，该成员的四种访问权限的含义如下：</p>
<ul>
<li>private：该成员可以被该类内部成员访问；</li>
<li>defalut：该成员可以被该类内部成员访问，也可以被同一包下其他的类访问；</li>
<li>protected：该成员可以被该类内部成员访问，也可以被同一包下其他的类访问，还可以被它的子类访問；</li>
<li>public：该成员可以被任意包下，任意类的成员进行访问。</li>
</ul>
<p>在修饰类时，该类只有两种访问权限，对应的访问权限的含义如下：</p>
<ul>
<li>defalut：该类可以被同一包下其他的类访问；</li>
<li>public：该类可以被任意包下，任意的类所访问。<h3 id="1-4-介绍一下Java的数据类型"><a href="#1-4-介绍一下Java的数据类型" class="headerlink" title="1.4 介绍一下Java的数据类型"></a>1.4 介绍一下Java的数据类型</h3>Java数据类型包括基本数据类型和引用数据类型两大类。<br>基本数据类型有8个，可以分为4个小类，分别是整数类型（byte/short/int/long）、浮点类型（float/double）、字符类型（char）、布尔类型（boolean）。其中，4个整数类型中，int类型最为常用。2个浮点类型中，double最为常用。另外，在这8个基本类型当中，除了布尔类型之外的其他7个类型，都可以看做是数字类型，它们相互之间可以进行类型转换。<br>引用类型就是对一个对象的引用，根据引用对象类型的不同，可以将引用类型分为3类，即数组、类、接口类型。引用类型本质上就是通过指针，指向堆中对象所持有的内存空间，只是Java语言不再沿用指针这个说法而已。</li>
</ul>
<h3 id="1-5-基本數據類型占用內存空間和數據范圍"><a href="#1-5-基本數據類型占用內存空間和數據范圍" class="headerlink" title="1.5 基本數據類型占用內存空間和數據范圍"></a>1.5 基本數據類型占用內存空間和數據范圍</h3><ul>
<li>byte：1字节（8位），数据范围是 -2^7 ~ 2^7-1。</li>
<li>short：2字节（16位），数据范围是 -2^15 ~ 2^15-1。</li>
<li>int：4字节（32位），数据范围是 -2^31 ~ 2^31-1。</li>
<li>long：8字节（64位），数据范围是 -2^63 ~ 2^63-1。</li>
<li>float：4字节（32位），数据范围大约是 -3.4<em>10^38 ~ 3.4</em>10^38。</li>
<li>double：8字节（64位），数据范围大约是 -1.8<em>10^308 ~ 1.8</em>10^308。</li>
<li>char：2字节（16位），数据范围是 \u0000 ~ \uffff。</li>
<li>boolean：Java规范没有明确的规定，不同的JVM有不同的实现机制。<h3 id="1-6-请介绍全局变量和局部变量的区别"><a href="#1-6-请介绍全局变量和局部变量的区别" class="headerlink" title="1.6 请介绍全局变量和局部变量的区别"></a>1.6 请介绍全局变量和局部变量的区别</h3>Java中的变量分为成员变量和局部变量，它们的区别如下：</li>
</ul>
<p>成员变量：</p>
<ul>
<li>成员变量是在类的范围里定义的变量；</li>
<li>成员变量有默认初始值；</li>
<li>未被static修饰的成员变量也叫实例变量，它存储于对象所在的堆内存中，生命周期与对象相同；</li>
<li>被static修饰的成员变量也叫类变量，它存储于方法区中，生命周期与当前类相同。<br>局部变量：</li>
<li>局部变量是在方法里定义的变量；</li>
<li>局部变量没有默认初始值；</li>
<li>局部变量存储于栈内存中，作用的范围结束，变量空间会自动的释放。<br>注意事项:<br>Java中没有真正的全局变量，面试官应该是出于其他语言的习惯说全局变量的，他的本意应该是指成员变量。<h3 id="1-7-请介绍一下实例变量的默认值"><a href="#1-7-请介绍一下实例变量的默认值" class="headerlink" title="1.7 请介绍一下实例变量的默认值"></a>1.7 请介绍一下实例变量的默认值</h3>实例变量若为引用数据类型，其默认值一律为null。若为基本数据类型，其默认值如下：</li>
<li>byte：0</li>
<li>short：0</li>
<li>int：0</li>
<li>long：0L</li>
<li>float：0.0F</li>
<li>double：0.0</li>
<li>char：’\u0000’</li>
<li>boolean：false<br>注意事项<br>上述默认值规则适用于所有的成员变量，所以对于类变量也是适用的。<h3 id="1-8-為啥要有包裝類"><a href="#1-8-為啥要有包裝類" class="headerlink" title="1.8 為啥要有包裝類"></a>1.8 為啥要有包裝類</h3>包装类是指在Java中，用于封装基本数据类型（如int、char、double等）的类。这些包装类提供了一些方法，可以方便地进行基本数据类型和对象之间的转换。</li>
</ul>
<p>在Java中，每个基本数据类型都有对应的包装类，例如：</p>
<ul>
<li>int 对应 Integer</li>
<li>char 对应 Character</li>
<li>double 对应 Double</li>
<li>boolean 对应 Boolean<br><code>Java语言是面向对象的语言，其设计理念是“一切皆对象”。但8种基本数据类型却出现了例外，它们不具备对象的特性。正是为了解决这个问题，Java为每个基本数据类型都定义了一个对应的引用类型，这就是包装类。</code></li>
</ul>
<p>扩展阅读:<br>Java之所以提供8种基本数据类型，主要是为了照顾程序员的传统习惯。这8种基本数据类型的确带来了一定的方便性，但在某些时候也会受到一些制约。比如，所有的引用类型的变量都继承于Object类，都可以当做Object类型的变量使用，但基本数据类型却不可以。如果某个方法需要Object类型的参数，但实际传入的值却是数字的话，就需要做特殊的处理了。有了包装类，这种问题就可以得以简化。</p>
<h3 id="1-9-说一说自动装箱、自动拆箱的应用场景"><a href="#1-9-说一说自动装箱、自动拆箱的应用场景" class="headerlink" title="1.9 说一说自动装箱、自动拆箱的应用场景"></a>1.9 说一说自动装箱、自动拆箱的应用场景</h3><p>自动装箱、自动拆箱是JDK1.5提供的功能。</p>
<p>自动装箱：可以把一个基本类型的数据直接赋值给对应的包装类型；</p>
<p>自动拆箱：可以把一个包装类型的对象直接赋值给对应的基本类型；</p>
<p>通过自动装箱、自动拆箱功能，可以大大简化基本类型变量和包装类对象之间的转换过程。比如，某个方法的参数类型为包装类型，调用时我们所持有的数据却是基本类型的值，则可以不做任何特殊的处理，直接将这个基本类型的值传入给方法即可。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Integer&gt;();</span><br><span class="line">list.add(<span class="number">1</span>); <span class="comment">// 自动装箱</span></span><br><span class="line"><span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> list.get(<span class="number">0</span>); <span class="comment">// 自动拆箱</span></span><br></pre></td></tr></table></figure></p>
<h3 id="1-10-如何对Integer和Double类型判断相等？"><a href="#1-10-如何对Integer和Double类型判断相等？" class="headerlink" title="1.10 如何对Integer和Double类型判断相等？"></a>1.10 如何对Integer和Double类型判断相等？</h3><p>Integer、Double不能直接进行比较，这包括：</p>
<ul>
<li>不能用==进行直接比较，因为它们是不同的数据类型；</li>
<li>不能转为字符串进行比较，因为转为字符串后，浮点值带小数点，整数值不带，这样它们永远都不相等；</li>
<li>不能使用compareTo方法进行比较，虽然它们都有compareTo方法，但该方法只能对相同类型进行比较。<br>整数、浮点类型的包装类，都继承于Number类型，而Number类型分别定义了将数字转换为byte、short、int、long、float、double的方法。所以，可以将Integer、Double先转为转换为相同的基本数据类型（如double），然后使用==进行比较。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Integer</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line"><span class="type">Double</span> <span class="variable">d</span> <span class="operator">=</span> <span class="number">100.00</span>;</span><br><span class="line">System.out.println(i.doubleValue() == d.doubleValue());</span><br></pre></td></tr></table></figure>
<h3 id="1-11-int和Integer有什么区别，二者在做-运算时会得到什么结果？"><a href="#1-11-int和Integer有什么区别，二者在做-运算时会得到什么结果？" class="headerlink" title="1.11 int和Integer有什么区别，二者在做==运算时会得到什么结果？"></a>1.11 int和Integer有什么区别，二者在做==运算时会得到什么结果？</h3>int是基本数据类型，Integer是int的包装类。二者在做==运算时，Integer会自动拆箱为int类型，然后再进行比较。届时，如果两个int值相等则返回true，否则就返回false。<h3 id="1-12-说一说你对面向对象的理解"><a href="#1-12-说一说你对面向对象的理解" class="headerlink" title="1.12 说一说你对面向对象的理解"></a>1.12 说一说你对面向对象的理解</h3>面向对象是一种更优秀的程序设计方法，它的基本思想是使用类、对象、继承、封装、消息等基本概念进行程序设计。它从现实世界中客观存在的事物出发来构造软件系统，并在系统构造中尽可能运用人类的自然思维方式，强调直接以现实世界中的事物为中心来思考，认识问题，并根据这些事物的本质特点，把它们抽象地表示为系统中的类，作为系统的基本构成单元，这使得软件系统的组件可以直接映像到客观世界，并保持客观世界中事物及其相互关系的本来面貌。</li>
</ul>
<p>扩展阅读</p>
<p>结构化程序设计方法主张按功能来分析系统需求，其主要原则可概括为自顶向下、逐步求精、模块化等。结构化程序设计首先采用结构化分析方法对系统进行需求分析，然后使用结构化设计方法对系统进行概要设计、详细设计，最后采用结构化编程方法来实现系统。</p>
<p>因为结构化程序设计方法主张按功能把软件系统逐步细分，因此这种方法也被称为面向功能的程序设计方法；结构化程序设计的每个功能都负责对数据进行一次处理，每个功能都接受一些数据，处理完后输出一些数据，这种处理方式也被称为面向数据流的处理方式。</p>
<p>结构化程序设计里最小的程序单元是函数，每个函数都负责完成一个功能，用以接收一些输入数据，函数对这些输入数据进行处理，处理结束后输出一些数据。整个软件系统由一个个函数组成，其中作为程序入口的函数被称为主函数，主函数依次调用其他普通函数，普通函数之间依次调用，从而完成整个软件系统的功能。</p>
<p>每个函数都是具有输入、输出的子系统，函数的输入数据包括函数形参、全局变量和常量等，函数的输出数据包括函数返回值以及传出参数等。结构化程序设计方式有如下两个局限性：</p>
<p>设计不够直观，与人类习惯思维不一致。采用结构化程序分析、设计时，开发者需要将客观世界模型分解成一个个功能，每个功能用以完成一定的数据处理。<br>适应性差，可扩展性不强。由于结构化设计采用自顶向下的设计方式，所以当用户的需求发生改变，或需要修改现有的实现方式时，都需要自顶向下地修改模块结构，这种方式的维护成本相当高。</p>
<h3 id="1-13-面向对象的三大特征是什么？"><a href="#1-13-面向对象的三大特征是什么？" class="headerlink" title="1.13 面向对象的三大特征是什么？"></a>1.13 面向对象的三大特征是什么？</h3><p>面向对象的程序设计方法具有三个基本特征：封装、继承、多态。其中，封装指的是将对象的实现细节隐藏起来，然后通过一些公用方法来暴露该对象的功能；继承是面向对象实现软件复用的重要手段，当子类继承父类后，子类作为一种特殊的父类，将直接获得父类的属性和方法；多态指的是子类对象可以直接赋给父类变量，但运行时依然表现出子类的行为特征，这意味着同一个类型的对象在执行同一个方法时，可能表现出多种行为特征。</p>
<p>扩展阅读:<br>抽象也是面向对象的重要部分，抽象就是忽略一个主题中与当前目标无关的那些方面，以便更充分地注意与当前目标有关的方面。抽象并不打算了解全部问题，而只是考虑部分问题。例如，需要考察Person对象时，不可能在程序中把Person的所有细节都定义出来，通常只能定义Person的部分数据、部分行为特征，而这些数据、行为特征是软件系统所关心的部分。</p>
<h3 id="1-14-封装的目的是什么，为什么要有封装？"><a href="#1-14-封装的目的是什么，为什么要有封装？" class="headerlink" title="1.14 封装的目的是什么，为什么要有封装？"></a>1.14 封装的目的是什么，为什么要有封装？</h3><p>封装是面向对象编程语言对客观世界的模拟，在客观世界里，对象的状态信息都被隐藏在对象内部，外界无法直接操作和修改。对一个类或对象实现良好的封装，可以实现以下目的：</p>
<ul>
<li>隐藏类的实现细节；</li>
<li>让使用者只能通过事先预定的方法来访问数据，从而可以在该方法里加入控制逻辑，限制对成员变量的不合理访问；</li>
<li>可进行数据检查，从而有利于保证对象信息的完整性；</li>
<li>便于修改，提高代码的可维护性。</li>
</ul>
<p>扩展阅读:<br>为了实现良好的封装，需要从两个方面考虑：<br>将对象的成员变量和实现细节隐藏起来，不允许外部直接访问；<br>把方法暴露出来，让方法来控制对这些成员变量进行安全的访问和操作。<br>封装实际上有两个方面的含义：把该隐藏的隐藏起来，把该暴露的暴露出来。这两个方面都需要通过使用Java提供的访问控制符来实现。</p>
<h3 id="1-15-说一说你对多态的理解"><a href="#1-15-说一说你对多态的理解" class="headerlink" title="1.15 说一说你对多态的理解"></a>1.15 说一说你对多态的理解</h3><p>因为子类其实是一种特殊的父类，因此Java允许把一个子类对象直接赋给一个父类引用变量，无须任何类型转换，或者被称为向上转型，向上转型由系统自动完成。</p>
<p>当把一个子类对象直接赋给父类引用变量时，例如 BaseClass obj = new SubClass();，这个obj引用变量的编译时类型是BaseClass，而运行时类型是SubClass，当运行时调用该引用变量的方法时，其方法行为总是表现出子类方法的行为特征，而不是父类方法的行为特征，这就可能出现：相同类型的变量、调用同一个方法时呈现出多种不同的行为特征，这就是多态。</p>
<h3 id="1-16-Java中的多态是怎么实现的？"><a href="#1-16-Java中的多态是怎么实现的？" class="headerlink" title="1.16 Java中的多态是怎么实现的？"></a>1.16 Java中的多态是怎么实现的？</h3><p>多态的实现离不开继承，在设计程序时，我们可以将参数的类型定义为父类型。在调用程序时，则可以根据实际情况，传入该父类型的某个子类型的实例，这样就实现了多态。对于父类型，可以有三种形式，即普通的类、抽象类、接口。对于子类型，则要根据它自身的特征，重写父类的某些方法，或实现抽象类/接口的某些抽象方法。</p>
<h3 id="1-17-Java为什么是单继承，为什么不能多继承？"><a href="#1-17-Java为什么是单继承，为什么不能多继承？" class="headerlink" title="1.17 Java为什么是单继承，为什么不能多继承？"></a>1.17 Java为什么是单继承，为什么不能多继承？</h3><p>首先，Java是单继承的，指的是Java中一个类只能有一个直接的父类。Java不能多继承，则是说Java中一个类不能直接继承多个父类。</p>
<p>其次，Java在设计时借鉴了C++的语法，而C++是支持多继承的。Java语言之所以摒弃了多继承的这项特征，是因为多继承容易产生混淆。比如，两个父类中包含相同的方法时，子类在调用该方法或重写该方法时就会迷惑。</p>
<p>准确来说，Java是可以实现”多继承”的。因为尽管一个类只能有一个直接父类，但是却可以有任意多个间接的父类。这样的设计方式，避免了多继承时所产生的混淆。</p>
<h3 id="1-18-说一说重写与重载的区别"><a href="#1-18-说一说重写与重载的区别" class="headerlink" title="1.18 说一说重写与重载的区别"></a>1.18 说一说重写与重载的区别</h3><p>重载发生在同一个类中，若多个方法之间方法名相同、参数列表不同，则它们构成重载的关系。重载与方法的返回值以及访问修饰符无关，即重载的方法不能根据返回类型进行区分。</p>
<p>重写发生在父类子类中，若子类方法想要和父类方法构成重写关系，则它的方法名、参数列表必须与父类方法相同。另外，返回值要小于等于父类方法，抛出的异常要小于等于父类方法，访问修饰符则要大于等于父类方法。还有，若父类方法的访问修饰符为private，则子类不能对其重写。</p>
<h3 id="1-19-构造方法能不能重写？"><a href="#1-19-构造方法能不能重写？" class="headerlink" title="1.19 构造方法能不能重写？"></a>1.19 构造方法能不能重写？</h3><p>构造方法不能重写。因为构造方法需要和类保持同名，而重写的要求是子类方法要和父类方法保持同名。如果允许重写构造方法的话，那么子类中将会存在与类名不同的构造方法，这与构造方法的要求是矛盾的。</p>
<h3 id="1-20-介绍一下Object类中的方法"><a href="#1-20-介绍一下Object类中的方法" class="headerlink" title="1.20 介绍一下Object类中的方法"></a>1.20 介绍一下Object类中的方法</h3><p>Object类提供了如下几个常用方法：</p>
<ul>
<li>Class&lt;?&gt; getClass()：返回该对象的运行时类。</li>
<li>boolean equals(Object obj)：判断指定对象与该对象是否相等。</li>
<li>int hashCode()：返回该对象的hashCode值。在默认情况下，Object类的hashCode()方法根据该对象的地址来计算。但很多类都重写了Object类的hashCode()方法，不再根据地址来计算其hashCode()方法值。</li>
<li>String toString()：返回该对象的字符串表示，当程序使用System.out.println()方法输出一个对象，或者把某个对象和字符串进行连接运算时，系统会自动调用该对象的toString()方法返回该对象的字符串表示。Object类的toString()方法返回 运行时类名@十六进制hashCode值 格式的字符串，但很多类都重写了Object类的toString()方法，用于返回可以表述该对象信息的字符串。<br>另外，Object类还提供了wait()、notify()、notifyAll()这几个方法，通过这几个方法可以控制线程的暂停和运行。Object类还提供了一个clone()方法，该方法用于帮助其他对象来实现“自我克隆”，所谓“自我克隆”就是得到一个当前对象的副本，而且二者之间完全隔离。由于该方法使用了protected修饰，因此它只能被子类重写或调用。<h3 id="1-21-说一说hashCode-和equals-的关系"><a href="#1-21-说一说hashCode-和equals-的关系" class="headerlink" title="1.21 说一说hashCode()和equals()的关系"></a>1.21 说一说hashCode()和equals()的关系</h3>hashCode()用于获取哈希码（散列码），eauqls()用于比较两个对象是否相等，它们应遵守如下规定：</li>
<li>如果两个对象相等，则它们必须有相同的哈希码。</li>
<li>如果两个对象有相同的哈希码，则它们未必相等。</li>
</ul>
<p>扩展阅读:<br>在Java中，Set接口代表无序的、元素不可重复的集合，HashSet则是Set接口的典型实现。<br>当向HashSet中加入一个元素时，它需要判断集合中是否已经包含了这个元素，从而避免重复存储。由于这个判断十分的频繁，所以要讲求效率，绝不能采用遍历集合逐个元素进行比较的方式。实际上，HashSet是通过获取对象的哈希码，以及调用对象的equals()方法来解决这个判断问题的。</p>
<p>HashSet首先会调用对象的hashCode()方法获取其哈希码，并通过哈希码确定该对象在集合中存放的位置。假设这个位置之前已经存了一个对象，则HashSet会调用equals()对两个对象进行比较。若相等则说明对象重复，此时不会保存新加的对象。若不等说明对象不重复，但是它们存储的位置发生了碰撞，此时HashSet会采用链式结构在同一位置保存多个对象，即将新加对象链接到原来对象的之后。之后，再有新添加对象也映射到这个位置时，就需要与这个位置中所有的对象进行equals()比较，若均不相等则将其链到最后一个对象之后。</p>
<h3 id="1-22-为什么要重写hashCode-和equals-？"><a href="#1-22-为什么要重写hashCode-和equals-？" class="headerlink" title="1.22 为什么要重写hashCode()和equals()？"></a>1.22 为什么要重写hashCode()和equals()？</h3><p>Object类提供的equals()方法默认是用==来进行比较的，也就是说只有两个对象是同一个对象时，才能返回相等的结果。而实际的业务中，我们通常的需求是，若两个不同的对象它们的内容是相同的，就认为它们相等。鉴于这种情况，Object类中equals()方法的默认实现是没有实用价值的，所以通常都要重写。</p>
<p>由于hashCode()与equals()具有联动关系（参考“说一说hashCode()和equals()的关系”一题），所以equals()方法重写时，通常也要将hashCode()进行重写，使得这两个方法始终满足相关的约定。</p>
<h3 id="1-23-和equals-有什么区别？"><a href="#1-23-和equals-有什么区别？" class="headerlink" title="1.23 ==和equals()有什么区别？"></a>1.23 ==和equals()有什么区别？</h3><p>==运算符：</p>
<ul>
<li>作用于基本数据类型时，是比较两个数值是否相等；</li>
<li>作用于引用数据类型时，是比较两个对象的内存地址是否相同，即判断它们是否为同一个对象；<br>equals()方法：</li>
<li>没有重写时，Object默认以 == 来实现，即比较两个对象的内存地址是否相同；</li>
<li>进行重写后，一般会按照对象的内容来进行比较，若两个对象内容相同则认为对象相等，否则认为对象不等。<h3 id="1-24-String类有哪些方法？"><a href="#1-24-String类有哪些方法？" class="headerlink" title="1.24 String类有哪些方法？"></a>1.24 String类有哪些方法？</h3>String类是Java最常用的API，它包含了大量处理字符串的方法，比较常用的有：</li>
</ul>
<p>char charAt(int index)：返回指定索引处的字符；<br>String substring(int beginIndex, int endIndex)：从此字符串中截取出一部分子字符串；<br>String[] split(String regex)：以指定的规则将此字符串分割成数组；<br>String trim()：删除字符串前导和后置的空格；<br>int indexOf(String str)：返回子串在此字符串首次出现的索引；<br>int lastIndexOf(String str)：返回子串在此字符串最后出现的索引；<br>boolean startsWith(String prefix)：判断此字符串是否以指定的前缀开头；<br>boolean endsWith(String suffix)：判断此字符串是否以指定的后缀结尾；<br>String toUpperCase()：将此字符串中所有的字符大写；<br>String toLowerCase()：将此字符串中所有的字符小写；<br>String replaceFirst(String regex, String replacement)：用指定字符串替换第一个匹配的子串；<br>String replaceAll(String regex, String replacement)：用指定字符串替换所有的匹配的子串。</p>
<p>注意事项:<br>String类的方法太多了，你没必要都记下来，更不需要一一列举。面试时能说出一些常用的方法，表现出对这个类足够的熟悉就可以了。另外，建议你挑几个方法仔细看看源码实现，面试时可以重点说这几个方法。</p>
<h3 id="1-25-String可以被继承吗？"><a href="#1-25-String可以被继承吗？" class="headerlink" title="1.25 String可以被继承吗？"></a>1.25 String可以被继承吗？</h3><p>String类由final修饰，所以不能被继承。<br>扩展阅读:</p>
<ul>
<li>由于字符串无论在任何 Java 系统中都广泛使用，会用来存储敏感信息，如账号，密码，网络路径，文件处理等场景里，保证字符串 String 类的安全性就尤为重要了，如果字符串是可变的，容易被篡改，那我们就无法保证使用字符串进行操作时，它是安全的，很有可能出现 SQL 注入，访问危险文件等操作。</li>
<li>在多线程中，只有不变的对象和值是线程安全的，可以在多个线程中共享数据。由于 String 天然的不可变，当一个线程”修改“了字符串的值，只会产生一个新的字符串对象，不会对其他线程的访问产生副作用，访问的都是同样的字符串数据，不需要任何同步操作。</li>
<li>字符串作为基础的数据结构，大量地应用在一些集合容器之中，尤其是一些散列集合，在散列集合中，存放元素都要根据对象的 hashCode() 方法来确定元素的位置。由于字符串 hashcode 属性不会变更，保证了唯一性，使得类似 HashMap，HashSet 等容器才能实现相应的缓存功能。由于 String 的不可变，避免重复计算 hashcode，只要使用缓存的 hashcode 即可，这样一来大大提高了在散列集合中使用 String 对象的性能。</li>
<li>当字符串不可变时，字符串常量池才有意义。字符串常量池的出现，可以减少创建相同字面量的字符串，让不同的引用指向池中同一个字符串，为运行时节约很多的堆内存。若字符串可变，字符串常量池失去意义，基于常量池的 String.intern() 方法也失效，每次创建新的字符串将在堆内开辟出新的空间，占据更多的内存。<h3 id="1-26-说一说String和StringBuffer有什么区别"><a href="#1-26-说一说String和StringBuffer有什么区别" class="headerlink" title="1.26 说一说String和StringBuffer有什么区别"></a>1.26 说一说String和StringBuffer有什么区别</h3>String类是不可变类，即一旦一个String对象被创建以后，包含在这个对象中的字符序列是不可改变的，直至这个对象被销毁。</li>
</ul>
<p>StringBuffer对象则代表一个字符序列可变的字符串，当一个StringBuffer被创建以后，通过StringBuffer提供的append()、insert()、reverse()、setCharAt()、setLength()等方法可以改变这个字符串对象的字符序列。一旦通过StringBuffer生成了最终想要的字符串，就可以调用它的toString()方法将其转换为一个String对象。</p>
<h3 id="1-27-说一说StringBuffer和StringBuilder有什么区别"><a href="#1-27-说一说StringBuffer和StringBuilder有什么区别" class="headerlink" title="1.27 说一说StringBuffer和StringBuilder有什么区别"></a>1.27 说一说StringBuffer和StringBuilder有什么区别</h3><p>StringBuffer、StringBuilder都代表可变的字符串对象，它们有共同的父类 AbstractStringBuilder，并且两个类的构造方法和成员方法也基本相同。不同的是，StringBuffer是线程安全的，而StringBuilder是非线程安全的，所以StringBuilder性能略高。一般情况下，要创建一个内容可变的字符串，建议优先考虑StringBuilder类。</p>
<h3 id="1-28-使用字符串时，new和””推荐使用哪种方式？"><a href="#1-28-使用字符串时，new和””推荐使用哪种方式？" class="headerlink" title="1.28 使用字符串时，new和””推荐使用哪种方式？"></a>1.28 使用字符串时，new和””推荐使用哪种方式？</h3><p>先看看 “hello” 和 new String(“hello”) 的区别：</p>
<ul>
<li>当Java程序直接使用 “hello” 的字符串直接量时，JVM将会使用常量池来管理这个字符串；</li>
<li>当使用 new String(“hello”) 时，JVM会先使用常量池来管理 “hello” 直接量，再调用String类的构造器来创建一个新的String对象，新创建的String对象被保存在堆内存中。<br>显然，采用new的方式会多创建一个对象出来，会占用更多的内存，所以一般建议使用直接量的方式创建字符串。</li>
</ul>
<h3 id="1-29-说一说你对字符串拼接的理解"><a href="#1-29-说一说你对字符串拼接的理解" class="headerlink" title="1.29 说一说你对字符串拼接的理解"></a>1.29 说一说你对字符串拼接的理解</h3><p>拼接字符串有很多种方式，其中最常用的有4种，下面列举了这4种方式各自适合的场景。</p>
<ol>
<li><ul>
<li>运算符：如果拼接的都是字符串直接量，则适合使用 + 运算符实现拼接；</li>
</ul>
</li>
<li>StringBuilder：如果拼接的字符串中包含变量，并不要求线程安全，则适合使用StringBuilder；</li>
<li>StringBuffer：如果拼接的字符串中包含变量，并且要求线程安全，则适合使用StringBuffer；</li>
<li>String类的concat方法：如果只是对两个字符串进行拼接，并且包含变量，则适合使用concat方法；</li>
</ol>
<p>扩展阅读:<br>采用 + 运算符拼接字符串时：</p>
<ul>
<li><p>如果拼接的都是字符串直接量，则在编译时编译器会将其直接优化为一个完整的字符串，和你直接写一个完整的字符串是一样的，所以效率非常的高。</p>
</li>
<li><p>如果拼接的字符串中包含变量，则在编译时编译器采用StringBuilder对其进行优化，即自动创建StringBuilder实例并调用其append()方法，将这些字符串拼接在一起，效率也很高。但如果这个拼接操作是在循环中进行的，那么每次循环编译器都会创建一个StringBuilder实例，再去拼接字符串，相当于执行了 new StringBuilder().append(str)，所以此时效率很低。</p>
</li>
</ul>
<p>采用StringBuilder/StringBuffer拼接字符串时：</p>
<ul>
<li>StringBuilder/StringBuffer都有字符串缓冲区，缓冲区的容量在创建对象时确定，并且默认为16。当拼接的字符串超过缓冲区的容量时，会触发缓冲区的扩容机制，即缓冲区加倍。</li>
<li><p>缓冲区频繁的扩容会降低拼接的性能，所以如果能提前预估最终字符串的长度，则建议在创建可变字符串对象时，放弃使用默认的容量，可以指定缓冲区的容量为预估的字符串的长度。<br>采用String类的concat方法拼接字符串时：</p>
</li>
<li><p>concat方法的拼接逻辑是，先创建一个足以容纳待拼接的两个字符串的字节数组，然后先后将两个字符串拼到这个数组里，最后将此数组转换为字符串。</p>
</li>
<li>在拼接大量字符串的时候，concat方法的效率低于StringBuilder。但是只拼接2个字符串时，concat方法的效率要优于StringBuilder。并且这种拼接方式代码简洁，所以只拼2个字符串时建议优先选择concat方法。</li>
</ul>
<h3 id="1-30-两个字符串相加的底层是如何实现的？"><a href="#1-30-两个字符串相加的底层是如何实现的？" class="headerlink" title="1.30 两个字符串相加的底层是如何实现的？"></a>1.30 两个字符串相加的底层是如何实现的？</h3><p>如果拼接的都是字符串直接量，则在编译时编译器会将其直接优化为一个完整的字符串，和你直接写一个完整的字符串是一样的。</p>
<p>如果拼接的字符串中包含变量，则在编译时编译器采用StringBuilder对其进行优化，即自动创建StringBuilder实例并调用其append()方法，将这些字符串拼接在一起。</p>
<h3 id="1-31-String-a-“abc”-，说一下这个过程会创建什么，放在哪里？"><a href="#1-31-String-a-“abc”-，说一下这个过程会创建什么，放在哪里？" class="headerlink" title="1.31 String a = “abc”; ，说一下这个过程会创建什么，放在哪里？"></a>1.31 String a = “abc”; ，说一下这个过程会创建什么，放在哪里？</h3><p>JVM会使用常量池来管理字符串直接量。在执行这句话时，JVM会先检查常量池中是否已经存有”abc”，若没有则将”abc”存入常量池，否则就复用常量池中已有的”abc”，将其引用赋值给变量a。</p>
<h3 id="1-32-new-String-“abc”-是去了哪里，仅仅是在堆里面吗？"><a href="#1-32-new-String-“abc”-是去了哪里，仅仅是在堆里面吗？" class="headerlink" title="1.32 new String(“abc”) 是去了哪里，仅仅是在堆里面吗？"></a>1.32 new String(“abc”) 是去了哪里，仅仅是在堆里面吗？</h3><p>在执行这句话时，JVM会先使用常量池来管理字符串直接量，即将”abc”存入常量池。然后再创建一个新的String对象，这个对象会被保存在堆内存中。并且，堆中对象的数据会指向常量池中的直接量。</p>
<h3 id="1-33-接口和抽象类有什么区别？"><a href="#1-33-接口和抽象类有什么区别？" class="headerlink" title="1.33 接口和抽象类有什么区别？"></a>1.33 接口和抽象类有什么区别？</h3><p>从设计目的上来说，二者有如下的区别：</p>
<p>接口体现的是一种规范。对于接口的实现者而言，接口规定了实现者必须向外提供哪些服务；对于接口的调用者而言，接口规定了调用者可以调用哪些服务，以及如何调用这些服务。当在一个程序中使用接口时，接口是多个模块间的耦合标准；当在多个应用程序之间使用接口时，接口是多个程序之间的通信标准。</p>
<p>抽象类体现的是一种模板式设计。抽象类作为多个子类的抽象父类，可以被当成系统实现过程中的中间产品，这个中间产品已经实现了系统的部分功能，但这个产品依然不能当成最终产品，必须有更进一步的完善，这种完善可能有几种不同方式。</p>
<p>从使用方式上来说，二者有如下的区别：</p>
<ul>
<li>接口里只能包含抽象方法、静态方法、默认方法和私有方法，不能为普通方法提供方法实现；抽象类则完全可以包含普通方法。</li>
<li>接口里只能定义静态常量，不能定义普通成员变量；抽象类里则既可以定义普通成员变量，也可以定义静态常量。</li>
<li>接口里不包含构造器；抽象类里可以包含构造器，抽象类里的构造器并不是用于创建对象，而是让其子类调用这些构造器来完成属于抽象类的初始化操作。</li>
<li>接口里不能包含初始化块；但抽象类则完全可以包含初始化块。</li>
<li>一个类最多只能有一个直接父类，包括抽象类；但一个类可以直接实现多个接口，通过实现多个接口可以弥补Java单继承的不足。</li>
</ul>
<p>扩展阅读:<br>接口和抽象类很像，它们都具有如下共同的特征：</p>
<ul>
<li>接口和抽象类都不能被实例化，它们都位于继承树的顶端，用于被其他类实现和继承。</li>
<li>接口和抽象类都可以包含抽象方法，实现接口或继承抽象类的普通子类都必须实现这些抽象方法。<h3 id="1-34-接口中可以有构造函数吗？"><a href="#1-34-接口中可以有构造函数吗？" class="headerlink" title="1.34 接口中可以有构造函数吗？"></a>1.34 接口中可以有构造函数吗？</h3>由于接口定义的是一种规范，因此接口里不能包含构造器和初始化块定义。接口里可以包含成员变量（只能是静态常量）、方法（只能是抽象实例方法、类方法、默认方法或私有方法）、内部类（包括内部接口、枚举）定义。<h3 id="1-35-谈谈你对面向接口编程的理解"><a href="#1-35-谈谈你对面向接口编程的理解" class="headerlink" title="1.35 谈谈你对面向接口编程的理解"></a>1.35 谈谈你对面向接口编程的理解</h3>接口体现的是一种规范和实现分离的设计哲学，充分利用接口可以极好地降低程序各模块之间的耦合，从而提高系统的可扩展性和可维护性。基于这种原则，很多软件架构设计理论都倡导“面向接口”编程，而不是面向实现类编程，希望通过面向接口编程来降低程序的耦合。<h3 id="1-36-遇到过异常吗，如何处理？"><a href="#1-36-遇到过异常吗，如何处理？" class="headerlink" title="1.36 遇到过异常吗，如何处理？"></a>1.36 遇到过异常吗，如何处理？</h3>在Java中，可以按照如下三个步骤处理异常：</li>
</ul>
<ol>
<li>捕获异常</li>
</ol>
<p>将业务代码包裹在try块内部，当业务代码中发生任何异常时，系统都会为此异常创建一个异常对象。创建异常对象之后，JVM会在try块之后寻找可以处理它的catch块，并将异常对象交给这个catch块处理。</p>
<ol>
<li>处理异常</li>
</ol>
<p>在catch块中处理异常时，应该先记录日志，便于以后追溯这个异常。然后根据异常的类型、结合当前的业务情况，进行相应的处理。比如，给变量赋予一个默认值、直接返回空值、向外抛出一个新的业务异常交给调用者处理，等等。</p>
<ol>
<li>回收资源</li>
</ol>
<p>如果业务代码打开了某个资源，比如数据库连接、网络连接、磁盘文件等，则需要在这段业务代码执行完毕后关闭这项资源。并且，无论是否发生异常，都要尝试关闭这项资源。将关闭资源的代码写在finally块内，可以满足这种需求，即无论是否发生异常，finally块内的代码总会被执行。</p>
<h3 id="1-37-说一说Java的异常机制"><a href="#1-37-说一说Java的异常机制" class="headerlink" title="1.37 说一说Java的异常机制"></a>1.37 说一说Java的异常机制</h3><p>在Java中，处理异常的语句由try、catch、finally三部分组成。其中，try块用于包裹业务代码，catch块用于捕获并处理某个类型的异常，finally块则用于回收资源。当业务代码发生异常时，系统会创建一个异常对象，然后由JVM寻找可以处理这个异常的catch块，并将异常对象交给这个catch块处理。若业务代码打开了某项资源，则可以在finally块中关闭这项资源，因为无论是否发生异常，finally块一定会执行。</p>
<p>关于抛出异常：</p>
<p>当程序出现错误时，系统会自动抛出异常。除此以外，Java也允许程序主动抛出异常。当业务代码中，判断某项错误的条件成立时，可以使用throw关键字向外抛出异常。在这种情况下，如果当前方法不知道该如何处理这个异常，可以在方法签名上通过throws关键字声明抛出异常，则该异常将交给JVM处理。</p>
<p>关于异常跟踪栈：</p>
<p>程序运行时，经常会发生一系列方法调用，从而形成方法调用栈。异常机制会导致异常在这些方法之间传播，而异常传播的顺序与方法的调用相反。异常从发生异常的方法向外传播，首先传给该方法的调用者，再传给上层调用者，以此类推。最终会传到main方法，若依然没有得到处理，则JVM会终止程序，并打印异常跟踪栈的信息</p>
<h3 id="1-38-请介绍Java的异常接口"><a href="#1-38-请介绍Java的异常接口" class="headerlink" title="1.38 请介绍Java的异常接口"></a>1.38 请介绍Java的异常接口</h3><p>Throwable是异常的顶层父类，代表所有的非正常情况。它有两个直接子类，分别是Error、Exception。</p>
<p>Error是错误，一般是指与虚拟机相关的问题，如系统崩溃、虚拟机错误、动态链接失败等，这种错误无法恢复或不可能捕获，将导致应用程序中断。通常应用程序无法处理这些错误，因此应用程序不应该试图使用catch块来捕获Error对象。在定义方法时，也无须在其throws子句中声明该方法可能抛出Error及其任何子类。</p>
<p>Exception是异常，它被分为两大类，分别是Checked异常和Runtime异常。所有的RuntimeException类及其子类的实例被称为Runtime异常；不是RuntimeException类及其子类的异常实例则被称为Checked异常。Java认为Checked异常都是可以被处理（修复）的异常，所以Java程序必须显式处理Checked异常。如果程序没有处理Checked异常，该程序在编译时就会发生错误，无法通过编译。Runtime异常则更加灵活，Runtime异常无须显式声明抛出，如果程序需要捕获Runtime异常，也可以使用try…catch块来实现。</p>
<h3 id="1-39-finally是无条件执行的吗？"><a href="#1-39-finally是无条件执行的吗？" class="headerlink" title="1.39 finally是无条件执行的吗？"></a>1.39 finally是无条件执行的吗？</h3><p>不管try块中的代码是否出现异常，也不管哪一个catch块被执行，甚至在try块或catch块中执行了return语句，finally块总会被执行。</p>
<p>注意事项:<br>如果在try块或catch块中使用 System.exit(1); 来退出虚拟机，则finally块将失去执行的机会。但是我们在实际的开发中，重来都不会这样做，所以尽管存在这种导致finally块无法执行的可能，也只是一种可能而已。</p>
<h3 id="1-40-在finally中return会发生什么？"><a href="#1-40-在finally中return会发生什么？" class="headerlink" title="1.40 在finally中return会发生什么？"></a>1.40 在finally中return会发生什么？</h3><p>在通常情况下，不要在finally块中使用return、throw等导致方法终止的语句，一旦在finally块中使用了return、throw语句，将会导致try块、catch块中的return、throw语句失效。</p>
<p>详细解析:<br>当Java程序执行try块、catch块时遇到了return或throw语句，这两个语句都会导致该方法立即结束，但是系统执行这两个语句并不会结束该方法，而是去寻找该异常处理流程中是否包含finally块，如果没有finally块，程序立即执行return或throw语句，方法终止；如果有finally块，系统立即开始执行finally块。只有当finally块执行完成后，系统才会再次跳回来执行try块、catch块里的return或throw语句；如果finally块里也使用了return或throw等导致方法终止的语句，finally块已经终止了方法，系统将不会跳回去执行try块、catch块里的任何代码。</p>
<h3 id="1-41-说一说你对static关键字的理解"><a href="#1-41-说一说你对static关键字的理解" class="headerlink" title="1.41 说一说你对static关键字的理解"></a>1.41 说一说你对static关键字的理解</h3><p>在Java类里只能包含成员变量、方法、构造器、初始化块、内部类（包括接口、枚举）5种成员，而static可以修饰成员变量、方法、初始化块、内部类（包括接口、枚举），以static修饰的成员就是类成员。类成员属于整个类，而不属于单个对象。</p>
<p>对static关键字而言，有一条非常重要的规则：类成员（包括成员变量、方法、初始化块、内部类和内部枚举）不能访问实例成员（包括成员变量、方法、初始化块、内部类和内部枚举）。因为类成员是属于类的，类成员的作用域比实例成员的作用域更大，完全可能出现类成员已经初始化完成，但实例成员还不曾初始化的情况，如果允许类成员访问实例成员将会引起大量错误。</p>
<h3 id="1-42-static修饰的类能不能被继承？"><a href="#1-42-static修饰的类能不能被继承？" class="headerlink" title="1.42 static修饰的类能不能被继承？"></a>1.42 static修饰的类能不能被继承？</h3><p>static修饰的类可以被继承。</p>
<p>扩展阅读:<br>如果使用static来修饰一个内部类，则这个内部类就属于外部类本身，而不属于外部类的某个对象。因此使用static修饰的内部类被称为类内部类，有的地方也称为静态内部类。<br>static关键字的作用是把类的成员变成类相关，而不是实例相关，即static修饰的成员属于整个类，而不属于单个对象。外部类的上一级程序单元是包，所以不可使用static修饰；而内部类的上一级程序单元是外部类，使用static修饰可以将内部类变成外部类相关，而不是外部类实例相关。因此static关键字不可修饰外部类，但可修饰内部类。<br>静态内部类需满足如下规则：</p>
<ol>
<li>静态内部类可以包含静态成员，也可以包含非静态成员；</li>
<li>静态内部类不能访问外部类的实例成员，只能访问它的静态成员；</li>
<li>外部类的所有方法、初始化块都能访问其内部定义的静态内部类；</li>
<li>在外部类的外部，也可以实例化静态内部类，语法如下：<br><code>外部类.内部类 变量名 = new 外部类.内部类构造方法();</code></li>
</ol>
<h3 id="1-43-static和final有什么区别？"><a href="#1-43-static和final有什么区别？" class="headerlink" title="1.43 static和final有什么区别？"></a>1.43 static和final有什么区别？</h3><p>static关键字可以修饰成员变量、成员方法、初始化块、内部类，被static修饰的成员是类的成员，它属于类、不属于单个对象。以下是static修饰这4种成员时表现出的特征：</p>
<ul>
<li>类变量：被static修饰的成员变量叫类变量（静态变量）。类变量属于类，它随类的信息存储在方法区，并不随对象存储在堆中，类变量可以通过类名来访问，也可以通过对象名来访问，但建议通过类名访问它。</li>
<li>类方法：被static修饰的成员方法叫类方法（静态方法）。类方法属于类，可以通过类名访问，也可以通过对象名访问，建议通过类名访问它。</li>
<li>静态块：被static修饰的初始化块叫静态初始化块。静态块属于类，它在类加载的时候被隐式调用一次，之后便不会被调用了。</li>
<li>静态内部类：被static修饰的内部类叫静态内部类。静态内部类可以包含静态成员，也可以包含非静态成员。静态内部类不能访问外部类的实例成员，只能访问外部类的静态成员。外部类的所有方法、初始化块都能访问其内部定义的静态内部类。</li>
</ul>
<p>final关键字可以修饰类、方法、变量，以下是final修饰这3种目标时表现出的特征：</p>
<ul>
<li>final类：final关键字修饰的类不可以被继承。</li>
<li>final方法：final关键字修饰的方法不可以被重写。</li>
<li>final变量：final关键字修饰的变量，一旦获得了初始值，就不可以被修改。</li>
</ul>
<h3 id="1-44-说一说你对泛型的理解"><a href="#1-44-说一说你对泛型的理解" class="headerlink" title="1.44 说一说你对泛型的理解"></a>1.44 说一说你对泛型的理解</h3><p>Java集合有个缺点—把一个对象“丢进”集合里之后，集合就会“忘记”这个对象的数据类型，当再次取出该对象时，该对象的编译类型就变成了Object类型（其运行时类型没变）。</p>
<p>Java集合之所以被设计成这样，是因为集合的设计者不知道我们会用集合来保存什么类型的对象，所以他们把集合设计成能保存任何类型的对象，只要求具有很好的通用性。但这样做带来如下两个问题：</p>
<p>集合对元素类型没有任何限制，这样可能引发一些问题。例如，想创建一个只能保存Dog对象的集合，但程序也可以轻易地将Cat对象“丢”进去，所以可能引发异常。<br>由于把对象“丢进”集合时，集合丢失了对象的状态信息，只知道它盛装的是Object，因此取出集合元素后通常还需要进行强制类型转换。这种强制类型转换既增加了编程的复杂度，也可能引发ClassCastException异常。<br>从Java 5开始，Java引入了“参数化类型”的概念，允许程序在创建集合时指定集合元素的类型，Java的参数化类型被称为泛型（Generic）。例如 List<String>，表明该List只能保存字符串类型的对象。</p>
<p>有了泛型以后，程序再也不能“不小心”地把其他对象“丢进”集合中。而且程序更加简洁，集合自动记住所有集合元素的数据类型，从而无须对集合元素进行强制类型转换。</p>
<h3 id="1-45-介绍一下泛型擦除"><a href="#1-45-介绍一下泛型擦除" class="headerlink" title="1.45 介绍一下泛型擦除"></a>1.45 介绍一下泛型擦除</h3><p>泛型擦除（Generic Type Erasure）是指在 Java 或者其他语言中使用泛型的时候，编译器在编译代码的时候会将泛型类型擦除成它的上限（通常是 Object 类型），并在运行时使用类型转换来保证类型安全性。</p>
<p>当把一个具有泛型信息的对象赋给另一个没有泛型信息的变量时，所有在尖括号之间的类型信息都将被扔掉。比如一个 List<String> 类型被转换为List，则该List对集合元素的类型检查变成了泛型参数的上限（即Object）。<br><code>List&lt;String&gt; list1 = ...;
List list2 = list1; // list2将元素当做Object处理</code></p>
<p>扩展阅读:<br>从逻辑上来看，List<String> 是List的子类，如果直接把一个List对象赋给一个List<String>对象应该引起编译错误，但实际上不会。对泛型而言，可以直接把一个List对象赋给一个 List<String> 对象，编译器仅仅提示“未经检查的转换”。</p>
<p>上述规则叫做泛型转换。</p>
<h3 id="1-46-List-lt-super-T-gt-和List-lt-extends-T-gt-有什么区别？"><a href="#1-46-List-lt-super-T-gt-和List-lt-extends-T-gt-有什么区别？" class="headerlink" title="1.46 List&lt;? super T&gt;和List&lt;? extends T&gt;有什么区别？"></a>1.46 List&lt;? super T&gt;和List&lt;? extends T&gt;有什么区别？</h3><ul>
<li>? 是类型通配符，List&lt;?&gt; 可以表示各种泛型List的父类，意思是元素类型未知的List；</li>
<li>List&lt;? super T&gt; 用于设定类型通配符的下限，此处?代表一个未知的类型，但它必须是T的父类型；</li>
<li>List&lt;? extends T&gt; 用于设定类型通配符的上限，此处?代表一个未知的类型，但它必须是T的子类型。</li>
</ul>
<p>扩展阅读:<br>在Java的早期设计中，允许把Integer[]数组赋值给Number[]变量，此时如果试图把一个Double对象保存到该Number[]数组中，编译可以通过，但在运行时抛出ArrayStoreException异常。这显然是一种不安全的设计，因此Java在泛型设计时进行了改进，它不再允许把 List<Integer> 对象赋值给 List<Number> 变量。</p>
<p>数组和泛型有所不同，假设Foo是Bar的一个子类型（子类或者子接口），那么Foo[]依然是Bar[]的子类型，但G<Foo> 不是 G<Bar> 的子类型。Foo[]自动向上转型为Bar[]的方式被称为型变，也就是说，Java的数组支持型变，但Java集合并不支持型变。Java泛型的设计原则是，只要代码在编译时没有出现警告，就不会遇到运行时ClassCastException异常。</p>
<h3 id="1-47-说一说你对Java反射机制的理解"><a href="#1-47-说一说你对Java反射机制的理解" class="headerlink" title="1.47 说一说你对Java反射机制的理解"></a>1.47 说一说你对Java反射机制的理解</h3><p>Java程序中的对象在运行时可以表现为两种类型，即编译时类型和运行时类型。例如 Person p = new Student(); ，这行代码将会生成一个p变量，该变量的编译时类型为Person，运行时类型为Student。</p>
<p>有时，程序在运行时接收到外部传入的一个对象，该对象的编译时类型是Object，但程序又需要调用该对象的运行时类型的方法。这就要求程序需要在运行时发现对象和类的真实信息，而解决这个问题有以下两种做法：</p>
<ul>
<li>第一种做法是假设在编译时和运行时都完全知道类型的具体信息，在这种情况下，可以先使用instanceof运算符进行判断，再利用强制类型转换将其转换成其运行时类型的变量即可。</li>
<li>第二种做法是编译时根本无法预知该对象和类可能属于哪些类，程序只依靠运行时信息来发现该对象和类的真实信息，这就必须使用反射。<br>具体来说，通过反射机制，我们可以实现如下的操作：</li>
<li>程序运行时，可以通过反射获得任意一个类的Class对象，并通过这个对象查看这个类的信息；</li>
<li>程序运行时，可以通过反射创建任意一个类的实例，并访问该实例的成员；</li>
<li>程序运行时，可以通过反射机制生成一个类的动态代理类或动态代理对象。</li>
</ul>
<p>Java反射机制提供了以下三个主要的类：</p>
<ol>
<li>Class类：代表一个Java类，可以获取该类的所有信息，包括类名、方法、属性等。</li>
<li>Constructor类：代表一个构造方法，可以用来创建对象。</li>
<li>Method类：代表一个方法，可以用来调用方法。</li>
</ol>
<p>使用Java反射机制，可以实现很多动态的操作，例如：</p>
<ol>
<li>动态创建对象：使用Class类的newInstance()方法可以动态地创建对象，无需使用new关键字。</li>
<li>动态调用方法：使用Method类的invoke()方法可以动态地调用方法，可以在运行时动态地调用任何一个方法。</li>
<li>动态获取属性：使用Class类的getField()方法或getDeclaredField()方法可以动态地获取一个属性，可以在运行时获取对象的任何一个属性。</li>
</ol>
<h3 id="1-48-Java反射在实际项目中有哪些应用场景？"><a href="#1-48-Java反射在实际项目中有哪些应用场景？" class="headerlink" title="1.48 Java反射在实际项目中有哪些应用场景？"></a>1.48 Java反射在实际项目中有哪些应用场景？</h3><p>Java的反射机制在实际项目中应用广泛，常见的应用场景有：</p>
<ul>
<li>使用JDBC时，如果要创建数据库的连接，则需要先通过反射机制加载数据库的驱动程序；</li>
<li>多数框架都支持注解/XML配置，从配置中解析出来的类是字符串，需要利用反射机制实例化；</li>
<li>面向切面编程（AOP）的实现方案，是在程序运行时创建目标对象的代理类，这必须由反射机制来实现。</li>
</ul>
<h3 id="1-49-说一说Java的四种引用方式"><a href="#1-49-说一说Java的四种引用方式" class="headerlink" title="1.49 说一说Java的四种引用方式"></a>1.49 说一说Java的四种引用方式</h3><p>Java对象的四种引用方式分别是强引用、软引用、弱引用、虚引用，具体含义如下：</p>
<ul>
<li>强引用：这是Java程序中最常见的引用方式，即程序创建一个对象，并把这个对象赋给一个引用变量，程序通过该引用变量来操作实际的对象。当一个对象被一个或一个以上的引用变量所引用时，它处于可达状态，不可能被系统垃圾回收机制回收。</li>
<li>软引用：当一个对象只有软引用时，它有可能被垃圾回收机制回收。对于只有软引用的对象而言，当系统内存空间足够时，它不会被系统回收，程序也可使用该对象。当系统内存空间不足时，系统可能会回收它。软引用通常用于对内存敏感的程序中。</li>
<li>弱引用：弱引用和软引用很像，但弱引用的引用级别更低。对于只有弱引用的对象而言，当系统垃圾回收机制运行时，不管系统内存是否足够，总会回收该对象所占用的内存。当然，并不是说当一个对象只有弱引用时，它就会立即被回收，正如那些失去引用的对象一样，必须等到系统垃圾回收机制运行时才会被回收。</li>
<li>虚引用：虚引用完全类似于没有引用。虚引用对对象本身没有太大影响，对象甚至感觉不到虚引用的存在。如果一个对象只有一个虚引用时，那么它和没有引用的效果大致相同。虚引用主要用于跟踪对象被垃圾回收的状态，虚引用不能单独使用，虚引用必须和引用队列联合使用。</li>
</ul>
<h2 id="集合类"><a href="#集合类" class="headerlink" title="集合类"></a>集合类</h2><h3 id="2-1-Java中有哪些容器（集合类）？"><a href="#2-1-Java中有哪些容器（集合类）？" class="headerlink" title="2.1 Java中有哪些容器（集合类）？"></a>2.1 Java中有哪些容器（集合类）？</h3><p>Java中的集合类主要由Collection和Map这两个接口派生而出，其中Collection接口又派生出三个子接口，分别是Set、List、Queue。所有的Java集合类，都是Set、List、Queue、Map这四个接口的实现类，这四个接口将集合分成了四大类，其中:</p>
<ul>
<li>Set代表无序的，元素不可重复的集合；</li>
<li>List代表有序的，元素可以重复的集合；</li>
<li>Queue代表先进先出（FIFO）的队列；<br>＊ Map代表具有映射关系（key-value）的集合。<br>这些接口拥有众多的实现类，其中最常用的实现类有HashSet、TreeSet、ArrayList、LinkedList、ArrayDeque、HashMap、TreeMap等。</li>
</ul>
<p>扩展阅读：<br>Collection体系的继承树：<br><img src="https://s2.loli.net/2023/03/02/tD4YlGx36ehjyHi.png" alt="collection体系繼承树.png"><br>Ｍap体系繼承树：<br><img src="https://s2.loli.net/2023/03/02/yMQwroW9CmuRhAg.png" alt="map体系繼承树.png"><br>紫色框体代表接口，其中加粗的是代表四类集合的接口。蓝色框体代表实现类，其中有阴影的是常用实现类。</p>
<h3 id="2-2-Java中的容器，线程安全和线程不安全的分别有哪些？"><a href="#2-2-Java中的容器，线程安全和线程不安全的分别有哪些？" class="headerlink" title="2.2 Java中的容器，线程安全和线程不安全的分别有哪些？"></a>2.2 Java中的容器，线程安全和线程不安全的分别有哪些？</h3><p>java.util包下的集合类大部分都是线程不安全的，例如我们常用的HashSet、TreeSet、ArrayList、LinkedList、ArrayDeque、HashMap、TreeMap，这些都是线程不安全的集合类，但是它们的优点是性能好。如果需要使用线程安全的集合类，则可以使用Collections工具类提供的synchronizedXxx()方法，将这些集合类包装成线程安全的集合类。</p>
<p>java.util包下也有线程安全的集合类，例如Vector、Hashtable。这些集合类都是比较古老的API，虽然实现了线程安全，但是性能很差。所以即便是需要使用线程安全的集合类，也建议将线程不安全的集合类包装成线程安全集合类的方式，而不是直接使用这些古老的API。</p>
<p>从Java5开始，Java在java.util.concurrent包下提供了大量支持高效并发访问的集合类，它们既能包装良好的访问性能，有能包装线程安全。这些集合类可以分为两部分，它们的特征如下：</p>
<ul>
<li><p>以Concurrent开头的集合类：<br>以Concurrent开头的集合类代表了支持并发访问的集合，它们可以支持多个线程并发写入访问，这些写入线程的所有操作都是线程安全的，但读取操作不必锁定。以Concurrent开头的集合类采用了更复杂的算法来保证永远不会锁住整个集合，因此在并发写入时有较好的性能。</p>
</li>
<li><p>以CopyOnWrite开头的集合类：<br>以CopyOnWrite开头的集合类采用复制底层数组的方式来实现写操作。当线程对此类集合执行读取操作时，线程将会直接读取集合本身，无须加锁与阻塞。当线程对此类集合执行写入操作时，集合会在底层复制一份新的数组，接下来对新的数组执行写入操作。由于对集合的写入操作都是对数组的副本执行操作，因此它是线程安全的。</p>
</li>
</ul>
<p>java.util.concurrent包下线程安全的集合类的体系结构：<br><img src="https://s2.loli.net/2023/03/02/man6proHTxQEeCt.png" alt="java-util-concurrent包下线程安全的集合类的体系结构.png"></p>
<h3 id="2-3-Map接口有哪些实现类？"><a href="#2-3-Map接口有哪些实现类？" class="headerlink" title="2.3 Map接口有哪些实现类？"></a>2.3 Map接口有哪些实现类？</h3><p>Map接口有很多实现类，其中比较常用的有HashMap、LinkedHashMap、TreeMap、ConcurrentHashMap。</p>
<p>对于不需要排序的场景，优先考虑使用HashMap，因为它是性能最好的Map实现。如果需要保证线程安全，则可以使用ConcurrentHashMap。它的性能好于Hashtable，因为它在put时采用分段锁/CAS的加锁机制，而不是像Hashtable那样，无论是put还是get都做同步处理。</p>
<p>对于需要排序的场景，如果需要按插入顺序排序则可以使用LinkedHashMap，如果需要将key按自然顺序排列甚至是自定义顺序排列，则可以选择TreeMap。如果需要保证线程安全，则可以使用Collections工具类将上述实现类包装成线程安全的Map。</p>
<h3 id="2-4-描述一下Map-put的过程"><a href="#2-4-描述一下Map-put的过程" class="headerlink" title="2.4 描述一下Map put的过程"></a>2.4 描述一下Map put的过程</h3><p>HashMap是最经典的Map实现，下面以它的视角介绍put的过程：</p>
<ol>
<li><p>首次扩容：<br>先判断数组是否为空，若数组为空则进行第一次扩容(resize);</p>
</li>
<li><p>计算索引：<br>通过hash算法，计算键值对在数组中的索引；</p>
</li>
<li><p>插入数据：</p>
</li>
</ol>
<ul>
<li>如果当前位置元素为空，则直接插入数据；</li>
<li>如果当前位置元素非空，且key已存在，则直接覆盖其value；</li>
<li>如果当前位置元素非空，且key不存在，则将数据链到链表末端；</li>
<li>若链表长度达到8，则将链表转换成红黑树，并将数据插入树中；</li>
</ul>
<ol>
<li>再次扩容:<br>如果数组中元素个数（size）超过threshold，则再次进行扩容操作。</li>
</ol>
<h3 id="2-5-如何得到一个线程安全的Map？"><a href="#2-5-如何得到一个线程安全的Map？" class="headerlink" title="2.5 如何得到一个线程安全的Map？"></a>2.5 如何得到一个线程安全的Map？</h3><ol>
<li>使用Collections工具类，将线程不安全的Map包装成线程安全的Map；</li>
<li>使用java.util.concurrent包下的Map，如ConcurrentHashMap；</li>
<li>不建议使用Hashtable，虽然Hashtable是线程安全的，但是性能较差。</li>
</ol>
<h3 id="2-6-HashMap有什么特点？"><a href="#2-6-HashMap有什么特点？" class="headerlink" title="2.6 HashMap有什么特点？"></a>2.6 HashMap有什么特点？</h3><ol>
<li>HashMap是线程不安全的实现；</li>
<li>HashMap可以使用null作为key或value。</li>
</ol>
<h3 id="2-7-JDK7和JDK8中的HashMap有什么区别？"><a href="#2-7-JDK7和JDK8中的HashMap有什么区别？" class="headerlink" title="2.7 JDK7和JDK8中的HashMap有什么区别？"></a>2.7 JDK7和JDK8中的HashMap有什么区别？</h3><p>JDK7中的HashMap，是基于数组+链表来实现的，它的底层维护一个Entry数组。它会根据计算的hashCode将对应的KV键值对存储到该数组中，一旦发生hashCode冲突，那么就会将该KV键值对放到对应的已有元素的后面， 此时便形成了一个链表式的存储结构。</p>
<p>JDK7中HashMap的实现方案有一个明显的缺点，即当Hash冲突严重时，在桶上形成的链表会变得越来越长，这样在查询时的效率就会越来越低，其时间复杂度为O(N)。</p>
<p>JDK8中的HashMap，是基于数组+链表+红黑树来实现的，它的底层维护一个Node数组。当链表的存储的数据个数大于等于8的时候，不再采用链表存储，而采用了红黑树存储结构。这么做主要是在查询的时间复杂度上进行优化，链表为O(N)，而红黑树一直是O(logN)，可以大大的提高查找性能。</p>
<h3 id="2-8-介绍一下HashMap底层的实现原理"><a href="#2-8-介绍一下HashMap底层的实现原理" class="headerlink" title="2.8 介绍一下HashMap底层的实现原理"></a>2.8 介绍一下HashMap底层的实现原理</h3><p>它基于hash算法，通过put方法和get方法存储和获取对象。</p>
<p>存储对象时，我们将K/V传给put方法时，它调用K的hashCode计算hash从而得到bucket位置，进一步存储，HashMap会根据当前bucket的占用情况自动调整容量(超过Load Facotr则resize为原来的2倍)。获取对象时，我们将K传给get，它调用hashCode计算hash从而得到bucket位置，并进一步调用equals()方法确定键值对。</p>
<p>如果发生碰撞的时候，HashMap通过链表将产生碰撞冲突的元素组织起来。在Java 8中，如果一个bucket中碰撞冲突的元素超过某个限制(默认是8)，则使用红黑树来替换链表，从而提高速度。</p>
<h3 id="2-9-介绍一下HashMap的扩容机制"><a href="#2-9-介绍一下HashMap的扩容机制" class="headerlink" title="2.9 介绍一下HashMap的扩容机制"></a>2.9 介绍一下HashMap的扩容机制</h3><p>数组的初始容量为16，而容量是以2的次方扩充的，一是为了提高性能使用足够大的数组，二是为了能使用位运算代替取模预算(据说提升了5~8倍)。</p>
<p>数组是否需要扩充是通过负载因子判断的，如果当前元素个数为数组容量的0.75时，就会扩充数组。这个0.75就是默认的负载因子，可由构造器传入。我们也可以设置大于1的负载因子，这样数组就不会扩充，牺牲性能，节省内存。</p>
<p>为了解决碰撞，数组中的元素是单向链表类型。当链表长度到达一个阈值时（7或8），会将链表转换成红黑树提高性能。而当链表长度缩小到另一个阈值时（6），又会将红黑树转换回单向链表提高性能。</p>
<p>对于第三点补充说明，检查链表长度转换成红黑树之前，还会先检测当前数组数组是否到达一个阈值（64），如果没有到达这个容量，会放弃转换，先去扩充数组。所以上面也说了链表长度的阈值是7或8，因为会有一次放弃转换的操作。</p>
<h3 id="2-10-HashMap中的循环链表是如何产生的？"><a href="#2-10-HashMap中的循环链表是如何产生的？" class="headerlink" title="2.10 HashMap中的循环链表是如何产生的？"></a>2.10 HashMap中的循环链表是如何产生的？</h3><p>在多线程的情况下，当重新调整HashMap大小的时候，就会存在条件竞争，因为如果两个线程都发现HashMap需要重新调整大小了，它们会同时试着调整大小。在调整大小的过程中，存储在链表中的元素的次序会反过来，因为移动到新的bucket位置的时候，HashMap并不会将元素放在链表的尾部，而是放在头部，这是为了避免尾部遍历。如果条件竞争发生了，那么就会产生死循环了。</p>
<h3 id="2-11-HashMap为什么用红黑树而不用B树？"><a href="#2-11-HashMap为什么用红黑树而不用B树？" class="headerlink" title="2.11 HashMap为什么用红黑树而不用B树？"></a>2.11 HashMap为什么用红黑树而不用B树？</h3><p>B/B+树多用于外存上时，B/B+也被成为一个磁盘友好的数据结构。</p>
<p>HashMap本来是数组+链表的形式，链表由于其查找慢的特点，所以需要被查找效率更高的树结构来替换。如果用B/B+树的话，在数据量不是很多的情况下，数据都会“挤在”一个结点里面，这个时候遍历效率就退化成了链表。</p>
<h3 id="2-12-HashMap为什么线程不安全？"><a href="#2-12-HashMap为什么线程不安全？" class="headerlink" title="2.12 HashMap为什么线程不安全？"></a>2.12 HashMap为什么线程不安全？</h3><p>HashMap在并发执行put操作时，可能会导致形成循环链表，从而引起死循环。</p>
<h3 id="2-13-HashMap如何实现线程安全？"><a href="#2-13-HashMap如何实现线程安全？" class="headerlink" title="2.13 HashMap如何实现线程安全？"></a>2.13 HashMap如何实现线程安全？</h3><ol>
<li>直接使用Hashtable类；</li>
<li>直接使用ConcurrentHashMap；</li>
<li>使用Collections将HashMap包装成线程安全的Map。</li>
</ol>
<h3 id="2-14-HashMap是如何解决哈希冲突的？"><a href="#2-14-HashMap是如何解决哈希冲突的？" class="headerlink" title="2.14 HashMap是如何解决哈希冲突的？"></a>2.14 HashMap是如何解决哈希冲突的？</h3><p>为了解决碰撞，数组中的元素是单向链表类型。当链表长度到达一个阈值时，会将链表转换成红黑树提高性能。而当链表长度缩小到另一个阈值时，又会将红黑树转换回单向链表提高性能。</p>
<h3 id="2-15-说一说HashMap和HashTable的区别"><a href="#2-15-说一说HashMap和HashTable的区别" class="headerlink" title="2.15 说一说HashMap和HashTable的区别"></a>2.15 说一说HashMap和HashTable的区别</h3><ol>
<li>Hashtable是一个线程安全的Map实现，但HashMap是线程不安全的实现，所以HashMap比Hashtable的性能高一点。</li>
<li>Hashtable不允许使用null作为key和value，如果试图把null值放进Hashtable中，将会引发空指针异常，但HashMap可以使用null作为key或value。<h2 id=""><a href="#" class="headerlink" title="#"></a>#</h2><h2 id="-1"><a href="#-1" class="headerlink" title="#"></a>#</h2><h2 id="-2"><a href="#-2" class="headerlink" title="#"></a>#</h2><h2 id="-3"><a href="#-3" class="headerlink" title="#"></a>#</h2><h2 id="-4"><a href="#-4" class="headerlink" title="#"></a>#</h2><h2 id="-5"><a href="#-5" class="headerlink" title="#"></a>#</h2><h2 id="-6"><a href="#-6" class="headerlink" title="#"></a>#</h2><h2 id="-7"><a href="#-7" class="headerlink" title="#"></a>#</h2><h2 id="-8"><a href="#-8" class="headerlink" title="#"></a>#</h2><h2 id="-9"><a href="#-9" class="headerlink" title="#"></a>#</h2><h2 id="-10"><a href="#-10" class="headerlink" title="#"></a>#</h2><h2 id="-11"><a href="#-11" class="headerlink" title="#"></a>#</h2><h2 id="-12"><a href="#-12" class="headerlink" title="#"></a>#</h2><h2 id="-13"><a href="#-13" class="headerlink" title="#"></a>#</h2><h2 id="-14"><a href="#-14" class="headerlink" title="#"></a>#</h2></li>
</ol>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="https://www.hongzixian.cn">HongZiXian</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章連結: </span><span class="post-copyright-info"><a href="https://www.hongzixian.cn/2023/02/27/Java%E9%9D%A2%E8%A9%A6%E7%9F%A5%E8%AD%98%E9%BB%9E/">https://www.hongzixian.cn/2023/02/27/Java%E9%9D%A2%E8%A9%A6%E7%9F%A5%E8%AD%98%E9%BB%9E/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版權聲明: </span><span class="post-copyright-info">本部落格所有文章除特別聲明外，均採用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 許可協議。轉載請註明來自 <a href="https://www.hongzixian.cn" target="_blank">King's Backyard</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Spring/">Spring</a><a class="post-meta__tags" href="/tags/%E6%9C%8D%E5%8B%99%E7%AB%AF/">服務端</a></div><div class="post_share"><div class="social-share" data-image="https://s2.loli.net/2023/02/26/VZb4gMHaKpovYEf.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2023/02/26/Linus%E7%A8%8B%E5%BA%8F%E8%A8%AD%E8%A8%88%E4%BD%9C%E4%B8%9A/"><img class="prev-cover" src="https://s2.loli.net/2023/02/26/VZb4gMHaKpovYEf.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">Linus程序設計作业</div></div></a></div><div class="next-post pull-right"><a href="/2023/03/08/%E6%9C%8D%E5%8B%99%E7%AB%AF%E9%96%8B%E7%99%BC-MVC%E6%A1%86%E6%9E%B6/"><img class="next-cover" src="https://s2.loli.net/2023/02/26/VZb4gMHaKpovYEf.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">服務端開發--Spring MVC框架</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相關推薦</span></div><div class="relatedPosts-list"><div><a href="/2023/03/08/%E6%9C%8D%E5%8B%99%E7%AB%AF%E9%96%8B%E7%99%BC-MVC%E6%A1%86%E6%9E%B6/" title="服務端開發--Spring MVC框架"><img class="cover" src="https://s2.loli.net/2023/02/26/VZb4gMHaKpovYEf.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-03-08</div><div class="title">服務端開發--Spring MVC框架</div></div></a></div><div><a href="/2023/02/26/%E6%9C%8D%E5%8B%99%E7%AB%AF%E9%96%8B%E7%99%BC-Spring%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5/" title="服務端開發--Spring"><img class="cover" src="https://s2.loli.net/2023/02/26/VZb4gMHaKpovYEf.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-02-26</div><div class="title">服務端開發--Spring</div></div></a></div></div></div><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 評論</span></div></div><div class="comment-wrap"><div><div id="twikoo-wrap"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://s2.loli.net/2022/11/22/gqkpnz3Prte8RQU.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">HongZiXian</div><div class="author-info__description"></div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">22</div></a><a href="/tags/"><div class="headline">標籤</div><div class="length-num">23</div></a><a href="/categories/"><div class="headline">分類</div><div class="length-num">6</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/a2064777923"><i class="fab fa-github"></i><span>前往我的主頁</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/a2064777923" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="/a2064777923@gmail.com" target="_blank" title="Email"><i class="fas fa-envelope"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">v2.6 配置了評論系統 <br> v2.5 加入外挂標簽 <br> v2.4 更新導航欄置中，音樂播放插件</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目錄</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-Java%E5%9F%BA%E7%A1%80"><span class="toc-number">1.</span> <span class="toc-text">1 Java基础</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-%E4%B8%BA%E4%BB%80%E4%B9%88Java%E4%BB%A3%E7%A0%81%E5%8F%AF%E4%BB%A5%E5%AE%9E%E7%8E%B0%E4%B8%80%E6%AC%A1%E7%BC%96%E5%86%99%E3%80%81%E5%88%B0%E5%A4%84%E8%BF%90%E8%A1%8C%EF%BC%9F"><span class="toc-number">1.1.</span> <span class="toc-text">1.1 为什么Java代码可以实现一次编写、到处运行？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-%E4%B8%80%E4%B8%AAJava%E6%96%87%E4%BB%B6%E9%87%8C%E5%8F%AF%E4%BB%A5%E6%9C%89%E5%A4%9A%E4%B8%AA%E7%B1%BB%E5%90%97-%E4%B8%8D%E5%90%AB%E5%86%85%E9%83%A8%E7%B1%BB"><span class="toc-number">1.2.</span> <span class="toc-text">1.2 一个Java文件里可以有多个类吗(不含内部类)?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-3-%E8%AF%B4%E4%B8%80%E8%AF%B4%E4%BD%A0%E5%AF%B9Java%E8%AE%BF%E9%97%AE%E6%9D%83%E9%99%90%E7%9A%84%E4%BA%86%E8%A7%A3"><span class="toc-number">1.3.</span> <span class="toc-text">1.3 说一说你对Java访问权限的了解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-4-%E4%BB%8B%E7%BB%8D%E4%B8%80%E4%B8%8BJava%E7%9A%84%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.4.</span> <span class="toc-text">1.4 介绍一下Java的数据类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-5-%E5%9F%BA%E6%9C%AC%E6%95%B8%E6%93%9A%E9%A1%9E%E5%9E%8B%E5%8D%A0%E7%94%A8%E5%85%A7%E5%AD%98%E7%A9%BA%E9%96%93%E5%92%8C%E6%95%B8%E6%93%9A%E8%8C%83%E5%9C%8D"><span class="toc-number">1.5.</span> <span class="toc-text">1.5 基本數據類型占用內存空間和數據范圍</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-6-%E8%AF%B7%E4%BB%8B%E7%BB%8D%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F%E5%92%8C%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">1.6.</span> <span class="toc-text">1.6 请介绍全局变量和局部变量的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-7-%E8%AF%B7%E4%BB%8B%E7%BB%8D%E4%B8%80%E4%B8%8B%E5%AE%9E%E4%BE%8B%E5%8F%98%E9%87%8F%E7%9A%84%E9%BB%98%E8%AE%A4%E5%80%BC"><span class="toc-number">1.7.</span> <span class="toc-text">1.7 请介绍一下实例变量的默认值</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-8-%E7%82%BA%E5%95%A5%E8%A6%81%E6%9C%89%E5%8C%85%E8%A3%9D%E9%A1%9E"><span class="toc-number">1.8.</span> <span class="toc-text">1.8 為啥要有包裝類</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-9-%E8%AF%B4%E4%B8%80%E8%AF%B4%E8%87%AA%E5%8A%A8%E8%A3%85%E7%AE%B1%E3%80%81%E8%87%AA%E5%8A%A8%E6%8B%86%E7%AE%B1%E7%9A%84%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-number">1.9.</span> <span class="toc-text">1.9 说一说自动装箱、自动拆箱的应用场景</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-10-%E5%A6%82%E4%BD%95%E5%AF%B9Integer%E5%92%8CDouble%E7%B1%BB%E5%9E%8B%E5%88%A4%E6%96%AD%E7%9B%B8%E7%AD%89%EF%BC%9F"><span class="toc-number">1.10.</span> <span class="toc-text">1.10 如何对Integer和Double类型判断相等？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-11-int%E5%92%8CInteger%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%8C%E4%BA%8C%E8%80%85%E5%9C%A8%E5%81%9A-%E8%BF%90%E7%AE%97%E6%97%B6%E4%BC%9A%E5%BE%97%E5%88%B0%E4%BB%80%E4%B9%88%E7%BB%93%E6%9E%9C%EF%BC%9F"><span class="toc-number">1.11.</span> <span class="toc-text">1.11 int和Integer有什么区别，二者在做&#x3D;&#x3D;运算时会得到什么结果？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-12-%E8%AF%B4%E4%B8%80%E8%AF%B4%E4%BD%A0%E5%AF%B9%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84%E7%90%86%E8%A7%A3"><span class="toc-number">1.12.</span> <span class="toc-text">1.12 说一说你对面向对象的理解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-13-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84%E4%B8%89%E5%A4%A7%E7%89%B9%E5%BE%81%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">1.13.</span> <span class="toc-text">1.13 面向对象的三大特征是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-14-%E5%B0%81%E8%A3%85%E7%9A%84%E7%9B%AE%E7%9A%84%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%8C%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E6%9C%89%E5%B0%81%E8%A3%85%EF%BC%9F"><span class="toc-number">1.14.</span> <span class="toc-text">1.14 封装的目的是什么，为什么要有封装？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-15-%E8%AF%B4%E4%B8%80%E8%AF%B4%E4%BD%A0%E5%AF%B9%E5%A4%9A%E6%80%81%E7%9A%84%E7%90%86%E8%A7%A3"><span class="toc-number">1.15.</span> <span class="toc-text">1.15 说一说你对多态的理解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-16-Java%E4%B8%AD%E7%9A%84%E5%A4%9A%E6%80%81%E6%98%AF%E6%80%8E%E4%B9%88%E5%AE%9E%E7%8E%B0%E7%9A%84%EF%BC%9F"><span class="toc-number">1.16.</span> <span class="toc-text">1.16 Java中的多态是怎么实现的？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-17-Java%E4%B8%BA%E4%BB%80%E4%B9%88%E6%98%AF%E5%8D%95%E7%BB%A7%E6%89%BF%EF%BC%8C%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E8%83%BD%E5%A4%9A%E7%BB%A7%E6%89%BF%EF%BC%9F"><span class="toc-number">1.17.</span> <span class="toc-text">1.17 Java为什么是单继承，为什么不能多继承？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-18-%E8%AF%B4%E4%B8%80%E8%AF%B4%E9%87%8D%E5%86%99%E4%B8%8E%E9%87%8D%E8%BD%BD%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">1.18.</span> <span class="toc-text">1.18 说一说重写与重载的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-19-%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95%E8%83%BD%E4%B8%8D%E8%83%BD%E9%87%8D%E5%86%99%EF%BC%9F"><span class="toc-number">1.19.</span> <span class="toc-text">1.19 构造方法能不能重写？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-20-%E4%BB%8B%E7%BB%8D%E4%B8%80%E4%B8%8BObject%E7%B1%BB%E4%B8%AD%E7%9A%84%E6%96%B9%E6%B3%95"><span class="toc-number">1.20.</span> <span class="toc-text">1.20 介绍一下Object类中的方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-21-%E8%AF%B4%E4%B8%80%E8%AF%B4hashCode-%E5%92%8Cequals-%E7%9A%84%E5%85%B3%E7%B3%BB"><span class="toc-number">1.21.</span> <span class="toc-text">1.21 说一说hashCode()和equals()的关系</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-22-%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E9%87%8D%E5%86%99hashCode-%E5%92%8Cequals-%EF%BC%9F"><span class="toc-number">1.22.</span> <span class="toc-text">1.22 为什么要重写hashCode()和equals()？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-23-%E5%92%8Cequals-%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">1.23.</span> <span class="toc-text">1.23 &#x3D;&#x3D;和equals()有什么区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-24-String%E7%B1%BB%E6%9C%89%E5%93%AA%E4%BA%9B%E6%96%B9%E6%B3%95%EF%BC%9F"><span class="toc-number">1.24.</span> <span class="toc-text">1.24 String类有哪些方法？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-25-String%E5%8F%AF%E4%BB%A5%E8%A2%AB%E7%BB%A7%E6%89%BF%E5%90%97%EF%BC%9F"><span class="toc-number">1.25.</span> <span class="toc-text">1.25 String可以被继承吗？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-26-%E8%AF%B4%E4%B8%80%E8%AF%B4String%E5%92%8CStringBuffer%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB"><span class="toc-number">1.26.</span> <span class="toc-text">1.26 说一说String和StringBuffer有什么区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-27-%E8%AF%B4%E4%B8%80%E8%AF%B4StringBuffer%E5%92%8CStringBuilder%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB"><span class="toc-number">1.27.</span> <span class="toc-text">1.27 说一说StringBuffer和StringBuilder有什么区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-28-%E4%BD%BF%E7%94%A8%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%97%B6%EF%BC%8Cnew%E5%92%8C%E2%80%9D%E2%80%9D%E6%8E%A8%E8%8D%90%E4%BD%BF%E7%94%A8%E5%93%AA%E7%A7%8D%E6%96%B9%E5%BC%8F%EF%BC%9F"><span class="toc-number">1.28.</span> <span class="toc-text">1.28 使用字符串时，new和””推荐使用哪种方式？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-29-%E8%AF%B4%E4%B8%80%E8%AF%B4%E4%BD%A0%E5%AF%B9%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%8B%BC%E6%8E%A5%E7%9A%84%E7%90%86%E8%A7%A3"><span class="toc-number">1.29.</span> <span class="toc-text">1.29 说一说你对字符串拼接的理解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-30-%E4%B8%A4%E4%B8%AA%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9B%B8%E5%8A%A0%E7%9A%84%E5%BA%95%E5%B1%82%E6%98%AF%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E7%9A%84%EF%BC%9F"><span class="toc-number">1.30.</span> <span class="toc-text">1.30 两个字符串相加的底层是如何实现的？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-31-String-a-%E2%80%9Cabc%E2%80%9D-%EF%BC%8C%E8%AF%B4%E4%B8%80%E4%B8%8B%E8%BF%99%E4%B8%AA%E8%BF%87%E7%A8%8B%E4%BC%9A%E5%88%9B%E5%BB%BA%E4%BB%80%E4%B9%88%EF%BC%8C%E6%94%BE%E5%9C%A8%E5%93%AA%E9%87%8C%EF%BC%9F"><span class="toc-number">1.31.</span> <span class="toc-text">1.31 String a &#x3D; “abc”; ，说一下这个过程会创建什么，放在哪里？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-32-new-String-%E2%80%9Cabc%E2%80%9D-%E6%98%AF%E5%8E%BB%E4%BA%86%E5%93%AA%E9%87%8C%EF%BC%8C%E4%BB%85%E4%BB%85%E6%98%AF%E5%9C%A8%E5%A0%86%E9%87%8C%E9%9D%A2%E5%90%97%EF%BC%9F"><span class="toc-number">1.32.</span> <span class="toc-text">1.32 new String(“abc”) 是去了哪里，仅仅是在堆里面吗？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-33-%E6%8E%A5%E5%8F%A3%E5%92%8C%E6%8A%BD%E8%B1%A1%E7%B1%BB%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">1.33.</span> <span class="toc-text">1.33 接口和抽象类有什么区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-34-%E6%8E%A5%E5%8F%A3%E4%B8%AD%E5%8F%AF%E4%BB%A5%E6%9C%89%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E5%90%97%EF%BC%9F"><span class="toc-number">1.34.</span> <span class="toc-text">1.34 接口中可以有构造函数吗？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-35-%E8%B0%88%E8%B0%88%E4%BD%A0%E5%AF%B9%E9%9D%A2%E5%90%91%E6%8E%A5%E5%8F%A3%E7%BC%96%E7%A8%8B%E7%9A%84%E7%90%86%E8%A7%A3"><span class="toc-number">1.35.</span> <span class="toc-text">1.35 谈谈你对面向接口编程的理解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-36-%E9%81%87%E5%88%B0%E8%BF%87%E5%BC%82%E5%B8%B8%E5%90%97%EF%BC%8C%E5%A6%82%E4%BD%95%E5%A4%84%E7%90%86%EF%BC%9F"><span class="toc-number">1.36.</span> <span class="toc-text">1.36 遇到过异常吗，如何处理？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-37-%E8%AF%B4%E4%B8%80%E8%AF%B4Java%E7%9A%84%E5%BC%82%E5%B8%B8%E6%9C%BA%E5%88%B6"><span class="toc-number">1.37.</span> <span class="toc-text">1.37 说一说Java的异常机制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-38-%E8%AF%B7%E4%BB%8B%E7%BB%8DJava%E7%9A%84%E5%BC%82%E5%B8%B8%E6%8E%A5%E5%8F%A3"><span class="toc-number">1.38.</span> <span class="toc-text">1.38 请介绍Java的异常接口</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-39-finally%E6%98%AF%E6%97%A0%E6%9D%A1%E4%BB%B6%E6%89%A7%E8%A1%8C%E7%9A%84%E5%90%97%EF%BC%9F"><span class="toc-number">1.39.</span> <span class="toc-text">1.39 finally是无条件执行的吗？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-40-%E5%9C%A8finally%E4%B8%ADreturn%E4%BC%9A%E5%8F%91%E7%94%9F%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">1.40.</span> <span class="toc-text">1.40 在finally中return会发生什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-41-%E8%AF%B4%E4%B8%80%E8%AF%B4%E4%BD%A0%E5%AF%B9static%E5%85%B3%E9%94%AE%E5%AD%97%E7%9A%84%E7%90%86%E8%A7%A3"><span class="toc-number">1.41.</span> <span class="toc-text">1.41 说一说你对static关键字的理解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-42-static%E4%BF%AE%E9%A5%B0%E7%9A%84%E7%B1%BB%E8%83%BD%E4%B8%8D%E8%83%BD%E8%A2%AB%E7%BB%A7%E6%89%BF%EF%BC%9F"><span class="toc-number">1.42.</span> <span class="toc-text">1.42 static修饰的类能不能被继承？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-43-static%E5%92%8Cfinal%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">1.43.</span> <span class="toc-text">1.43 static和final有什么区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-44-%E8%AF%B4%E4%B8%80%E8%AF%B4%E4%BD%A0%E5%AF%B9%E6%B3%9B%E5%9E%8B%E7%9A%84%E7%90%86%E8%A7%A3"><span class="toc-number">1.44.</span> <span class="toc-text">1.44 说一说你对泛型的理解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-45-%E4%BB%8B%E7%BB%8D%E4%B8%80%E4%B8%8B%E6%B3%9B%E5%9E%8B%E6%93%A6%E9%99%A4"><span class="toc-number">1.45.</span> <span class="toc-text">1.45 介绍一下泛型擦除</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-46-List-lt-super-T-gt-%E5%92%8CList-lt-extends-T-gt-%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">1.46.</span> <span class="toc-text">1.46 List&lt;? super T&gt;和List&lt;? extends T&gt;有什么区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-47-%E8%AF%B4%E4%B8%80%E8%AF%B4%E4%BD%A0%E5%AF%B9Java%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6%E7%9A%84%E7%90%86%E8%A7%A3"><span class="toc-number">1.47.</span> <span class="toc-text">1.47 说一说你对Java反射机制的理解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-48-Java%E5%8F%8D%E5%B0%84%E5%9C%A8%E5%AE%9E%E9%99%85%E9%A1%B9%E7%9B%AE%E4%B8%AD%E6%9C%89%E5%93%AA%E4%BA%9B%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF%EF%BC%9F"><span class="toc-number">1.48.</span> <span class="toc-text">1.48 Java反射在实际项目中有哪些应用场景？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-49-%E8%AF%B4%E4%B8%80%E8%AF%B4Java%E7%9A%84%E5%9B%9B%E7%A7%8D%E5%BC%95%E7%94%A8%E6%96%B9%E5%BC%8F"><span class="toc-number">1.49.</span> <span class="toc-text">1.49 说一说Java的四种引用方式</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9B%86%E5%90%88%E7%B1%BB"><span class="toc-number">2.</span> <span class="toc-text">集合类</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-Java%E4%B8%AD%E6%9C%89%E5%93%AA%E4%BA%9B%E5%AE%B9%E5%99%A8%EF%BC%88%E9%9B%86%E5%90%88%E7%B1%BB%EF%BC%89%EF%BC%9F"><span class="toc-number">2.1.</span> <span class="toc-text">2.1 Java中有哪些容器（集合类）？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-Java%E4%B8%AD%E7%9A%84%E5%AE%B9%E5%99%A8%EF%BC%8C%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E5%92%8C%E7%BA%BF%E7%A8%8B%E4%B8%8D%E5%AE%89%E5%85%A8%E7%9A%84%E5%88%86%E5%88%AB%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F"><span class="toc-number">2.2.</span> <span class="toc-text">2.2 Java中的容器，线程安全和线程不安全的分别有哪些？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-Map%E6%8E%A5%E5%8F%A3%E6%9C%89%E5%93%AA%E4%BA%9B%E5%AE%9E%E7%8E%B0%E7%B1%BB%EF%BC%9F"><span class="toc-number">2.3.</span> <span class="toc-text">2.3 Map接口有哪些实现类？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-4-%E6%8F%8F%E8%BF%B0%E4%B8%80%E4%B8%8BMap-put%E7%9A%84%E8%BF%87%E7%A8%8B"><span class="toc-number">2.4.</span> <span class="toc-text">2.4 描述一下Map put的过程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-5-%E5%A6%82%E4%BD%95%E5%BE%97%E5%88%B0%E4%B8%80%E4%B8%AA%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E7%9A%84Map%EF%BC%9F"><span class="toc-number">2.5.</span> <span class="toc-text">2.5 如何得到一个线程安全的Map？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-6-HashMap%E6%9C%89%E4%BB%80%E4%B9%88%E7%89%B9%E7%82%B9%EF%BC%9F"><span class="toc-number">2.6.</span> <span class="toc-text">2.6 HashMap有什么特点？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-7-JDK7%E5%92%8CJDK8%E4%B8%AD%E7%9A%84HashMap%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">2.7.</span> <span class="toc-text">2.7 JDK7和JDK8中的HashMap有什么区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-8-%E4%BB%8B%E7%BB%8D%E4%B8%80%E4%B8%8BHashMap%E5%BA%95%E5%B1%82%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86"><span class="toc-number">2.8.</span> <span class="toc-text">2.8 介绍一下HashMap底层的实现原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-9-%E4%BB%8B%E7%BB%8D%E4%B8%80%E4%B8%8BHashMap%E7%9A%84%E6%89%A9%E5%AE%B9%E6%9C%BA%E5%88%B6"><span class="toc-number">2.9.</span> <span class="toc-text">2.9 介绍一下HashMap的扩容机制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-10-HashMap%E4%B8%AD%E7%9A%84%E5%BE%AA%E7%8E%AF%E9%93%BE%E8%A1%A8%E6%98%AF%E5%A6%82%E4%BD%95%E4%BA%A7%E7%94%9F%E7%9A%84%EF%BC%9F"><span class="toc-number">2.10.</span> <span class="toc-text">2.10 HashMap中的循环链表是如何产生的？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-11-HashMap%E4%B8%BA%E4%BB%80%E4%B9%88%E7%94%A8%E7%BA%A2%E9%BB%91%E6%A0%91%E8%80%8C%E4%B8%8D%E7%94%A8B%E6%A0%91%EF%BC%9F"><span class="toc-number">2.11.</span> <span class="toc-text">2.11 HashMap为什么用红黑树而不用B树？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-12-HashMap%E4%B8%BA%E4%BB%80%E4%B9%88%E7%BA%BF%E7%A8%8B%E4%B8%8D%E5%AE%89%E5%85%A8%EF%BC%9F"><span class="toc-number">2.12.</span> <span class="toc-text">2.12 HashMap为什么线程不安全？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-13-HashMap%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%EF%BC%9F"><span class="toc-number">2.13.</span> <span class="toc-text">2.13 HashMap如何实现线程安全？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-14-HashMap%E6%98%AF%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%E5%93%88%E5%B8%8C%E5%86%B2%E7%AA%81%E7%9A%84%EF%BC%9F"><span class="toc-number">2.14.</span> <span class="toc-text">2.14 HashMap是如何解决哈希冲突的？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-15-%E8%AF%B4%E4%B8%80%E8%AF%B4HashMap%E5%92%8CHashTable%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">2.15.</span> <span class="toc-text">2.15 说一说HashMap和HashTable的区别</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link"><span class="toc-number">3.</span> <span class="toc-text">#</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#-1"><span class="toc-number">4.</span> <span class="toc-text">#</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#-2"><span class="toc-number">5.</span> <span class="toc-text">#</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#-3"><span class="toc-number">6.</span> <span class="toc-text">#</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#-4"><span class="toc-number">7.</span> <span class="toc-text">#</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#-5"><span class="toc-number">8.</span> <span class="toc-text">#</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#-6"><span class="toc-number">9.</span> <span class="toc-text">#</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#-7"><span class="toc-number">10.</span> <span class="toc-text">#</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#-8"><span class="toc-number">11.</span> <span class="toc-text">#</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#-9"><span class="toc-number">12.</span> <span class="toc-text">#</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#-10"><span class="toc-number">13.</span> <span class="toc-text">#</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#-11"><span class="toc-number">14.</span> <span class="toc-text">#</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#-12"><span class="toc-number">15.</span> <span class="toc-text">#</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#-13"><span class="toc-number">16.</span> <span class="toc-text">#</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#-14"><span class="toc-number">17.</span> <span class="toc-text">#</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2023/03/08/%E6%9C%8D%E5%8B%99%E7%AB%AF%E9%96%8B%E7%99%BC-MVC%E6%A1%86%E6%9E%B6/" title="服務端開發--Spring MVC框架"><img src="https://s2.loli.net/2023/02/26/VZb4gMHaKpovYEf.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="服務端開發--Spring MVC框架"/></a><div class="content"><a class="title" href="/2023/03/08/%E6%9C%8D%E5%8B%99%E7%AB%AF%E9%96%8B%E7%99%BC-MVC%E6%A1%86%E6%9E%B6/" title="服務端開發--Spring MVC框架">服務端開發--Spring MVC框架</a><time datetime="2023-03-08T11:30:21.000Z" title="發表於 2023-03-08 19:30:21">2023-03-08</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/02/27/Java%E9%9D%A2%E8%A9%A6%E7%9F%A5%E8%AD%98%E9%BB%9E/" title="Java面試知識點"><img src="https://s2.loli.net/2023/02/26/VZb4gMHaKpovYEf.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Java面試知識點"/></a><div class="content"><a class="title" href="/2023/02/27/Java%E9%9D%A2%E8%A9%A6%E7%9F%A5%E8%AD%98%E9%BB%9E/" title="Java面試知識點">Java面試知識點</a><time datetime="2023-02-27T04:46:31.000Z" title="發表於 2023-02-27 12:46:31">2023-02-27</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/02/26/Linus%E7%A8%8B%E5%BA%8F%E8%A8%AD%E8%A8%88%E4%BD%9C%E4%B8%9A/" title="Linus程序設計作业"><img src="https://s2.loli.net/2023/02/26/VZb4gMHaKpovYEf.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Linus程序設計作业"/></a><div class="content"><a class="title" href="/2023/02/26/Linus%E7%A8%8B%E5%BA%8F%E8%A8%AD%E8%A8%88%E4%BD%9C%E4%B8%9A/" title="Linus程序設計作业">Linus程序設計作业</a><time datetime="2023-02-26T06:13:31.000Z" title="發表於 2023-02-26 14:13:31">2023-02-26</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/02/26/%E6%9C%8D%E5%8B%99%E7%AB%AF%E9%96%8B%E7%99%BC-Spring%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5/" title="服務端開發--Spring"><img src="https://s2.loli.net/2023/02/26/VZb4gMHaKpovYEf.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="服務端開發--Spring"/></a><div class="content"><a class="title" href="/2023/02/26/%E6%9C%8D%E5%8B%99%E7%AB%AF%E9%96%8B%E7%99%BC-Spring%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5/" title="服務端開發--Spring">服務端開發--Spring</a><time datetime="2023-02-26T06:13:31.000Z" title="發表於 2023-02-26 14:13:31">2023-02-26</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/12/07/Web%E5%89%8D%E8%AB%AF%E6%B0%B4%E5%8D%B0%E6%96%B9%E6%A1%88/" title="Web前端水印方案"><img src="https://s2.loli.net/2022/12/07/6D1ymZrpxqoh5e7.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Web前端水印方案"/></a><div class="content"><a class="title" href="/2022/12/07/Web%E5%89%8D%E8%AB%AF%E6%B0%B4%E5%8D%B0%E6%96%B9%E6%A1%88/" title="Web前端水印方案">Web前端水印方案</a><time datetime="2022-12-07T06:16:07.000Z" title="發表於 2022-12-07 14:16:07">2022-12-07</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url('https://s2.loli.net/2023/02/26/skohyb8aJQMduKF.png')"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2023 By HongZiXian</div><div class="footer_custom_text">事穷势蹙之人，当原其初心；功成行满之士，要观其末路 -- 洪应明<p><a target="_blank" href="https://hexo.io/"><img src="https://img.shields.io/badge/Frame-Hexo-blue?style=flat&logo=hexo" title="博客框架为Hexo"></a>&nbsp;<a target="_blank" href="https://butterfly.js.org/"><img src="https://img.shields.io/badge/Theme-Butterfly-6513df?style=flat&logo=bitdefender" title="主题采用butterfly"></a>&nbsp;<a target="_blank" href="https://www.jsdelivr.com/"><img src="https://img.shields.io/badge/CDN-jsDelivr-orange?style=flat&logo=jsDelivr" title="本站使用JsDelivr为静态资源提供CDN加速"></a> &nbsp;<a target="_blank" href="https://vercel.com/ "><img src="https://img.shields.io/badge/Hosted-Vervel-brightgreen?style=flat&logo=Vercel" title="本站采用双线部署，默认线路托管于Vercel"></a>&nbsp;<a target="_blank" href="https://vercel.com/ "><img src="https://img.shields.io/badge/Hosted-Coding-0cedbe?style=flat&logo=Codio" title="本站采用双线部署，联通线路托管于Coding"></a>&nbsp;<a target="_blank" href="https://github.com/a2064777923/a2064777923.github.io"><img src="https://img.shields.io/badge/Source-Github-d021d6?style=flat&logo=GitHub" title="本站项目由Gtihub托管"></a>&nbsp;<a target="_blank" href="http://creativecommons.org/licenses/by-nc-sa/4.0/"><img src="https://img.shields.io/badge/Copyright-BY--NC--SA%204.0-d42328?style=flat&logo=Claris" title="本站采用知识共享署名-非商业性使用-相同方式共享4.0国际许可协议进行许可"></a></p></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="閱讀模式"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="簡繁轉換">繁</button><button id="darkmode" type="button" title="淺色和深色模式轉換"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="單欄和雙欄切換"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="設定"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目錄"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直達評論"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到頂部"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜尋</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  資料庫載入中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜尋文章" type="text"/></div></div><hr/><div id="local-search-results"></div></div></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><script src="/js/search/local-search.js"></script><div class="js-pjax"><script>(()=>{
  const init = () => {
    twikoo.init(Object.assign({
      el: '#twikoo-wrap',
      envId: 'https://twikoo-system.hongzixian.cn/',
      region: '',
      onCommentLoaded: function () {
        btf.loadLightbox(document.querySelectorAll('#twikoo .tk-content img:not(.tk-owo-emotion)'))
      }
    }, null))
  }

  const getCount = () => {
    const countELement = document.getElementById('twikoo-count')
    if(!countELement) return
    twikoo.getCommentsCount({
      envId: 'https://twikoo-system.hongzixian.cn/',
      region: '',
      urls: [window.location.pathname],
      includeReply: false
    }).then(function (res) {
      countELement.innerText = res[0].count
    }).catch(function (err) {
      console.error(err);
    });
  }

  const runFn = () => {
    init()
    
  }

  const loadTwikoo = () => {
    if (typeof twikoo === 'object') {
      setTimeout(runFn,0)
      return
    } 
    getScript('https://cdn.jsdelivr.net/npm/twikoo/dist/twikoo.all.min.js').then(runFn)
  }

  if ('Twikoo' === 'Twikoo' || !true) {
    if (true) btf.loadComment(document.getElementById('twikoo-wrap'), loadTwikoo)
    else loadTwikoo()
  } else {
    window.loadOtherComment = () => {
      loadTwikoo()
    }
  }
})()</script></div><div class="aplayer no-destroy" data-id="2459826936" data-server="netease" data-type="playlist" data-fixed="true" data-autoplay="true"> </div><script id="click-heart" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/click-heart.min.js" async="async" mobile="false"></script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/metingjs/dist/Meting.min.js"></script><script src="https://cdn.jsdelivr.net/npm/pjax/pjax.min.js"></script><script>let pjaxSelectors = ["head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]

var pjax = new Pjax({
  elements: 'a:not([target="_blank"])',
  selectors: pjaxSelectors,
  cacheBust: false,
  analytics: false,
  scrollRestoration: false
})

document.addEventListener('pjax:send', function () {

  // removeEventListener scroll 
  window.tocScrollFn && window.removeEventListener('scroll', window.tocScrollFn)
  window.scrollCollect && window.removeEventListener('scroll', scrollCollect)

  document.getElementById('rightside').style.cssText = "opacity: ''; transform: ''"
  
  if (window.aplayers) {
    for (let i = 0; i < window.aplayers.length; i++) {
      if (!window.aplayers[i].options.fixed) {
        window.aplayers[i].destroy()
      }
    }
  }

  typeof typed === 'object' && typed.destroy()

  //reset readmode
  const $bodyClassList = document.body.classList
  $bodyClassList.contains('read-mode') && $bodyClassList.remove('read-mode')

  typeof disqusjs === 'object' && disqusjs.destroy()
})

document.addEventListener('pjax:complete', function () {
  window.refreshFn()

  document.querySelectorAll('script[data-pjax]').forEach(item => {
    const newScript = document.createElement('script')
    const content = item.text || item.textContent || item.innerHTML || ""
    Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
    newScript.appendChild(document.createTextNode(content))
    item.parentNode.replaceChild(newScript, item)
  })

  GLOBAL_CONFIG.islazyload && window.lazyLoadInstance.update()

  typeof chatBtnFn === 'function' && chatBtnFn()
  typeof panguInit === 'function' && panguInit()

  // google analytics
  typeof gtag === 'function' && gtag('config', '', {'page_path': window.location.pathname});

  // baidu analytics
  typeof _hmt === 'object' && _hmt.push(['_trackPageview',window.location.pathname]);

  typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()

  // prismjs
  typeof Prism === 'object' && Prism.highlightAll()
})

document.addEventListener('pjax:error', (e) => {
  if (e.request.status === 404) {
    pjax.loadUrl('/404.html')
  }
})</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div><!-- hexo injector body_end start --><script data-pjax>
    function butterfly_categories_card_injector_config(){
      var parent_div_git = document.getElementById('recent-posts');
      var item_html = '<style>li.categoryBar-list-item{width:32.3%;}.categoryBar-list{max-height: 380px;overflow:auto;}.categoryBar-list::-webkit-scrollbar{width:0!important}@media screen and (max-width: 650px){.categoryBar-list{max-height: 320px;}}</style><div class="recent-post-item" style="height:auto;width:100%;padding:0px;"><div id="categoryBar"><ul class="categoryBar-list"><li class="categoryBar-list-item" style="background:url(https://s2.loli.net/2022/11/26/9YKJdwjMPZkNuC2.jpg);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/web前端/&quot;);" href="javascript:void(0);">web前端</a><span class="categoryBar-list-count">3</span><span class="categoryBar-list-descr">web前端</span></li><li class="categoryBar-list-item" style="background:url(https://s2.loli.net/2022/11/22/KpEUIoJz1nrmL6P.jpg);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/C/&quot;);" href="javascript:void(0);">C++</a><span class="categoryBar-list-count">1</span><span class="categoryBar-list-descr">博客相關</span></li><li class="categoryBar-list-item" style="background:url(https://s2.loli.net/2022/11/24/jwF6iMUQARpGISo.jpg);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/煩人作業/&quot;);" href="javascript:void(0);">煩人作業</a><span class="categoryBar-list-count">9</span><span class="categoryBar-list-descr">煩人作業</span></li><li class="categoryBar-list-item" style="background:url(https://s2.loli.net/2022/12/08/yv5DLReTwmUEMOx.jpg);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/服務端開發/&quot;);" href="javascript:void(0);">服務端開發</a><span class="categoryBar-list-count">3</span><span class="categoryBar-list-descr">C++</span></li><li class="categoryBar-list-item" style="background:url(https://s2.loli.net/2022/11/29/MlsVrg46WYSGhXd.jpg);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/博客相關/&quot;);" href="javascript:void(0);">博客相關</a><span class="categoryBar-list-count">4</span><span class="categoryBar-list-descr">操作系統</span></li><li class="categoryBar-list-item" style="background:url(null);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/操作系統/&quot;);" href="javascript:void(0);">操作系統</a><span class="categoryBar-list-count">1</span><span class="categoryBar-list-descr">服務端開發</span></li></ul></div></div>';
      console.log('已挂载butterfly_categories_card')
      parent_div_git.insertAdjacentHTML("afterbegin",item_html)
      }
    if( document.getElementById('recent-posts') && (location.pathname ==='/'|| '/' ==='all')){
    butterfly_categories_card_injector_config()
    }
  </script><div class="js-pjax"><script async="async">var arr = document.getElementsByClassName('recent-post-item');
for(var i = 0;i<arr.length;i++){
    arr[i].classList.add('wow');
    arr[i].classList.add('animate__zoomIn');
    arr[i].setAttribute('data-wow-duration', '2s');
    arr[i].setAttribute('data-wow-delay', '1s');
    arr[i].setAttribute('data-wow-offset', '100');
    arr[i].setAttribute('data-wow-iteration', '1');
  }</script><script async="async">var arr = document.getElementsByClassName('card-widget');
for(var i = 0;i<arr.length;i++){
    arr[i].classList.add('wow');
    arr[i].classList.add('animate__zoomIn');
    arr[i].setAttribute('data-wow-duration', '');
    arr[i].setAttribute('data-wow-delay', '');
    arr[i].setAttribute('data-wow-offset', '');
    arr[i].setAttribute('data-wow-iteration', '');
  }</script></div><script defer src="https://npm.elemecdn.com/hexo-butterfly-wowjs/lib/wow.min.js"></script><script defer src="https://npm.elemecdn.com/hexo-butterfly-wowjs/lib/wow_init.js"></script><script async src="//at.alicdn.com/t/font_2032782_8d5kxvn09md.js"></script><!-- hexo injector body_end end --></body></html>