<!DOCTYPE html><html lang="zh-TW" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>C++概述 | King's Backyard</title><meta name="author" content="HongZiXian"><meta name="copyright" content="HongZiXian"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="程序員是應該被相信的!與可能出現的錯誤相比，更重要的是能做甚麼好的事情  簡介C++是一種高級程序設計語言，它是由Bjarne Stroustrup在C語言的基礎上開發而成的。C++擁有豐富的數據類型和運算符，支持面向對象程序設計，提供了強大的抽象能力和擴展性。C++可以用于開發各種應用程序，包括桌面應用程序、遊戲、科學計算和物聯網等領域。C++ 是 C 的超集，很多的C中的库都被C++兼容了最簡">
<meta property="og:type" content="article">
<meta property="og:title" content="C++概述">
<meta property="og:url" content="https://www.hongzixian.cn/2022/04/12/C++%E6%A6%82%E8%BF%B0/index.html">
<meta property="og:site_name" content="King&#39;s Backyard">
<meta property="og:description" content="程序員是應該被相信的!與可能出現的錯誤相比，更重要的是能做甚麼好的事情  簡介C++是一種高級程序設計語言，它是由Bjarne Stroustrup在C語言的基礎上開發而成的。C++擁有豐富的數據類型和運算符，支持面向對象程序設計，提供了強大的抽象能力和擴展性。C++可以用于開發各種應用程序，包括桌面應用程序、遊戲、科學計算和物聯網等領域。C++ 是 C 的超集，很多的C中的库都被C++兼容了最簡">
<meta property="og:locale" content="zh_TW">
<meta property="og:image" content="https://s2.loli.net/2022/12/08/ACt1YB2fTUVuILP.png">
<meta property="article:published_time" content="2022-04-12T10:06:01.000Z">
<meta property="article:modified_time" content="2022-04-18T01:43:18.000Z">
<meta property="article:author" content="HongZiXian">
<meta property="article:tag" content="筆記">
<meta property="article:tag" content="C++">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://s2.loli.net/2022/12/08/ACt1YB2fTUVuILP.png"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://www.hongzixian.cn/2022/04/12/C++%E6%A6%82%E8%BF%B0/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="/css/font.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"languages":{"hits_empty":"找不到您查詢的內容：${query}"}},
  translate: {"defaultEncoding":1,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":200},
  copy: {
    success: '複製成功',
    error: '複製錯誤',
    noSupport: '瀏覽器不支援'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '剛剛',
    min: '分鐘前',
    hour: '小時前',
    day: '天前',
    month: '個月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'C++概述',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2022-04-18 09:43:18'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/custom.css" media="defer" onload="this.media='all'"><link rel="stylesheet" href="/css/progress_bar.css"><!-- hexo injector head_end start --><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-tag-plugins-plus@latest/lib/assets/font-awesome-animation.min.css" media="defer" onload="this.media='all'"><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-tag-plugins-plus@1.0.17/lib/tag_plugins.css" media="defer" onload="this.media='all'"><script src="https://npm.elemecdn.com/hexo-butterfly-tag-plugins-plus@latest/lib/assets/carousel-touch.js"></script><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-categories-card@1.0.0/lib/categorybar.css"><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-wowjs/lib/animate.min.css" media="print" onload="this.media='screen'"><!-- hexo injector head_end end --><meta name="generator" content="Hexo 6.3.0"></head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">載入中...</div></div></div><script>const preloader = {
  endLoading: () => {
    document.body.style.overflow = 'auto';
    document.getElementById('loading-box').classList.add("loaded")
  },
  initLoading: () => {
    document.body.style.overflow = '';
    document.getElementById('loading-box').classList.remove("loaded")

  }
}
window.addEventListener('load',()=> { preloader.endLoading() })

if (true) {
  document.addEventListener('pjax:send', () => { preloader.initLoading() })
  document.addEventListener('pjax:complete', () => { preloader.endLoading() })
}</script><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://s2.loli.net/2022/11/22/gqkpnz3Prte8RQU.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">18</div></a><a href="/tags/"><div class="headline">標籤</div><div class="length-num">19</div></a><a href="/categories/"><div class="headline">分類</div><div class="length-num">5</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首頁</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 文檔</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 標簽</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分類</span></a></div><div class="menus_item"><a class="site-page group hide" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 清單</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音樂</span></a></li><li><a class="site-page child" href="/Gallery/"><i class="fa-fw fas fa-images"></i><span> 圖片</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 影片</span></a></li><li><a class="site-page child" href="/ETD/"><i class="fa-fw fas fa-light fa-heart"></i><span> 心電</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友鏈</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 關於</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://s2.loli.net/2022/12/08/UVKDqt6r1GP5F7z.png')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">King's Backyard</a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首頁</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 文檔</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 標簽</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分類</span></a></div><div class="menus_item"><a class="site-page group hide" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 清單</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音樂</span></a></li><li><a class="site-page child" href="/Gallery/"><i class="fa-fw fas fa-images"></i><span> 圖片</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 影片</span></a></li><li><a class="site-page child" href="/ETD/"><i class="fa-fw fas fa-light fa-heart"></i><span> 心電</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友鏈</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 關於</span></a></div></div><div id="nav-right"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜尋</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">C++概述</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">發表於</span><time class="post-meta-date-created" datetime="2022-04-12T10:06:01.000Z" title="發表於 2022-04-12 18:06:01">2022-04-12</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新於</span><time class="post-meta-date-updated" datetime="2022-04-18T01:43:18.000Z" title="更新於 2022-04-18 09:43:18">2022-04-18</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/C/">C++</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字數總計:</span><span class="word-count">8.1k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">閱讀時長:</span><span>30分鐘</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="C++概述"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">閱讀量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><div class='wow animate__flip' data-wow-duration='' data-wow-delay='' data-wow-offset=''  data-wow-iteration='' ><div class="note yellow icon-padding modern"><i class="note-icon far fa-hand-scissors"></i><p>程序員是應該被相信的!<br>與可能出現的錯誤相比，更重要的是能做甚麼好的事情</p>
</div></div>
<h2 id="簡介"><a href="#簡介" class="headerlink" title="簡介"></a>簡介</h2><p>C++是一種高級程序設計語言，它是由Bjarne Stroustrup在C語言的基礎上開發而成的。C++擁有豐富的數據類型和運算符，支持面向對象程序設計，提供了強大的抽象能力和擴展性。C++可以用于開發各種應用程序，包括桌面應用程序、遊戲、科學計算和物聯網等領域。C++ 是 C 的超集，很多的C中的库都被C++兼容了<br>最簡單的c++程序:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;Hello, World!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>這段代碼的功能是：首先包含iostream標頭文件，然後定義main函數，並在函數中通過std::cout語句向標準輸出設備輸出”Hello, World!”字符串。最後通過return 0;語句退出函數并結束程序。</p>
<h2 id="程序語句"><a href="#程序語句" class="headerlink" title="程序語句"></a>程序語句</h2><p>程序语句包含表达式语句、IO语句和控制流语句</p>
<h3 id="條件結構"><a href="#條件結構" class="headerlink" title="條件結構"></a>條件結構</h3><ol>
<li>if-else</li>
<li>switch：break(enum 枚举类型)</li>
</ol>
<ul>
<li>整形常量表达式:5、const、enum、define(对于compiler是固定的)</li>
<li>值不重复</li>
<li>次序任意(特指case)</li>
<li>switch可以和enum结合使用，将具体数值解耦</li>
<li>switch的进一步进一步优化可以尝试使用打表<span class="bubble-content">(表驅動)</span><span class="bubble-notation"><span class="bubble-item" style="background-color:#71a4e3;"> 表驅動是一種軟件設計模式，它將程序的控制流和業務逻辑與數據存儲分離，通過表格的形式來描述程序的控制流和業務逻辑。這種模式可以使程序更易于維護和修改，提高程序的靈活性和可擴展性。表驅動的實現常常需要用到查表法和分支語句等技術。</span></span>的方法</li>
</ul>
<ol>
<li><code>表达式1?表达式2:表达式3</code></li>
</ol>
<h3 id="循環結構"><a href="#循環結構" class="headerlink" title="循環結構"></a>循環結構</h3><ol>
<li>while</li>
<li>do-while</li>
<li>for</li>
<li>break和continue</li>
</ol>
<h3 id="命名空間"><a href="#命名空間" class="headerlink" title="命名空間"></a>命名空間</h3><p>作用:進一步解決了全局變量/函數的名冲突</p>
<ul>
<li>別名</li>
<li>全局</li>
<li>開放</li>
<li>可嵌套</li>
<li>可重載</li>
</ul>
<p>兩種形式:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">namespce L&#123;</span><br><span class="line">  <span class="type">int</span> k;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(<span class="type">int</span>)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//1.declaration:</span></span><br><span class="line"><span class="keyword">using</span> L::K;</span><br><span class="line"><span class="keyword">using</span> L::f;</span><br><span class="line"></span><br><span class="line">k=<span class="number">0</span>;</span><br><span class="line"><span class="built_in">f</span>(<span class="number">6</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//2.directive:全局应用</span></span><br><span class="line"><span class="keyword">using</span> namespce L;</span><br><span class="line">k=<span class="number">0</span>;</span><br><span class="line"><span class="built_in">f</span>(<span class="number">6</span>);</span><br></pre></td></tr></table></figure></p>
<h2 id="表逹式"><a href="#表逹式" class="headerlink" title="表逹式"></a>表逹式</h2><ol>
<li>C++中的表逹式由<code>operand</code>、<code>operator</code>和<code>others</code>組成</li>
<li>可以大致分為以下几種:</li>
</ol>
<ul>
<li>算术(a++,++a(-a))</li>
<li>關係和邏輯(&amp;&amp;, ||)</li>
<li>賦值(=)</li>
<li>逗號(就是連續運算)</li>
<li>字位運算符<code>(~,&amp;,|,^)</code></li>
</ul>
<div class="tip bell"><p>操作符可以重載以實現多態 </p>
</div>
<ol>
<li>求值會受到的制約有:</li>
</ol>
<ul>
<li>优先級</li>
<li>結合性</li>
<li>類型轉換約定(強制類型轉換:coresion，casting)</li>
<li>求值次序:受到編譯器影響</li>
<li>副作用</li>
</ul>
<h3 id="基本運算符"><a href="#基本運算符" class="headerlink" title="基本運算符"></a>基本運算符</h3><div class="table-container">
<table>
<thead>
<tr>
<th>运算符</th>
<th>名称</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>&lt;&lt;</code></td>
<td>插入运算符</td>
<td>将后面的插入流中去，也可以被理解为重定向运算符</td>
</tr>
<tr>
<td><code>&gt;&gt;</code></td>
<td>取出运算符</td>
<td>按顺序读入参数，以空格为分隔符</td>
</tr>
<tr>
<td><code>~</code></td>
<td>取反运算符</td>
<td>按位取反</td>
</tr>
<tr>
<td><code>*</code></td>
<td>指针运算符</td>
<td>取出指针所对应的内存地址中的值</td>
</tr>
<tr>
<td><code>sizeof</code></td>
<td>求字节数运算符</td>
<td>返回该变量或者数据结构占据的字节数</td>
</tr>
<tr>
<td><code>-&gt;</code></td>
<td>指向成员运算符</td>
<td>用于拿到成员中变量</td>
</tr>
</tbody>
</table>
</div>
<p>還有二元運算符和逗號運算符</p>
<h3 id="賦值表逹式"><a href="#賦值表逹式" class="headerlink" title="賦值表逹式"></a>賦值表逹式</h3><ol>
<li>C++为左值表达式</li>
<li>左值 = 右值表达式<br>左值:可以出现在赋值表达式左部的表达式，具有存放数据的空间。<br>类型不同时，先计算右值表达式的值，然后转换为左值表达式，之后赋值</li>
<li>C++11中出现了右值表达式，int &amp;&amp; x = 1</li>
</ol>
<h3 id="條件表逹式"><a href="#條件表逹式" class="headerlink" title="條件表逹式"></a>條件表逹式</h3><ol>
<li><code>&lt;exp1&gt;?&lt;exp2&gt;:&lt;exp3&gt;</code></li>
<li>唯一的三目运算符,不允许进行重载</li>
<li>如果<code>&lt;exp2&gt;</code>和<code>&lt;exp3&gt;</code>的值类型相同且均为左值，则该条件运算符表达式为左值表达式。</li>
<li>可以嵌套(满足就近原则</li>
</ol>
<h2 id="數據"><a href="#數據" class="headerlink" title="數據"></a>數據</h2><p>数据的组成:名、值、地址、类型、性质</p>
<h3 id="數據類型"><a href="#數據類型" class="headerlink" title="數據類型"></a>數據類型</h3><ol>
<li>基本類型: 都属於Built-in的類型</li>
</ol>
<ul>
<li>整型 int(shor int, int ,long int)</li>
<li>字符型 char</li>
<li>浮點型 float(float,double,long double)</li>
<li>布尔型 bool</li>
</ul>
<ol>
<li>派生類型</li>
</ol>
<ul>
<li>指針類型 *</li>
<li>枚舉類型 enum</li>
<li>數組類型 <code>[]</code></li>
<li>結構體類型 struct</li>
<li>公用體類型 union</li>
<li>類類型 class</li>
</ul>
<ol>
<li>空類型 void<br>数据类型是第一层的封装，包括了Value Set和Operation</li>
</ol>
<h3 id="抽象數據類型ADT"><a href="#抽象數據類型ADT" class="headerlink" title="抽象數據類型ADT"></a>抽象數據類型ADT</h3><p>抽象數據類型（Abstract Data Type, ADT）是一種程序設計中的概念，它定義了一組數據類型的通用操作，而不關心其具體實現細節。抽象數據類型旨在提供一種抽象的、統一的方式來描述和操作數據結構，並隔離數據的實現細節和使用方式。<br>抽象數據類型的主要特徵有：</p>
<ul>
<li>定義了一組通用的、高層次的數據操作，如增加、刪除、查找等。</li>
<li>封裝了數據的實現細節，只提供外部可以訪問的接口。</li>
<li>提供了一種統一的、模塊化的方式來描述數據結構，方便程序的設計和維護。<br>抽象數據類型在程序設計中非常重要，它可以減少程序代碼的耦合度，提高程序的可讀性和可維護性，方便對數據的操作和管理。抽象數據類型的具體實現可以通過各種數據結構來完成，如陣列、鏈表、樹、圖等。<br>類型系統:</li>
</ul>
<ol>
<li>强/弱:是指类型严格与否，弱类型允许进行隐式转换</li>
<li>静/动:静是指在编译之前就已经确定类型，而动是指在编译过程中确定类型。</li>
</ol>
<h3 id="typedef關鍵字"><a href="#typedef關鍵字" class="headerlink" title="typedef關鍵字"></a>typedef關鍵字</h3><ol>
<li>用来为已有的类型定义一个同义词(别名)</li>
<li>格式:<code>typedef [原本类型][同义词/别名]</code></li>
<li>提高程序可移植性(应用的价值所在)</li>
</ol>
<ul>
<li>16位系统:typedef int INT16</li>
<li>32位系统:typedef short INT16</li>
</ul>
<ol>
<li>是为了已有类型定义别名，而不是定义新的类型</li>
</ol>
<h3 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h3><ol>
<li>整型表示:0開頭(8進制)、0x開头(16進制)等</li>
<li>浮點數表示:十進制和指數形式等</li>
<li>字符常量(字符串常量結尾<code>\0</code>)</li>
<li>符號常量(#define NUM 1)</li>
<li>枚舉常量</li>
</ol>
<h3 id="變量"><a href="#變量" class="headerlink" title="變量"></a>變量</h3><ol>
<li>局部變量<br>在函數局部等地方生存</li>
<li>全局變量<br>從定義位置到程序結束都是有效的</li>
<li>自動變量<br>如果不用static声明变量类型，编译器对它们是动态地分配储存空间的</li>
<li>指針變量</li>
</ol>
<ul>
<li>int <code>*</code>pointer;定义</li>
<li>&amp;取地址运算符</li>
<li><code>*</code>间接访问运算符:访问地址上的函数值。</li>
</ul>
<ol>
<li>作用域</li>
</ol>
<ul>
<li>文件作用域</li>
<li>函数作用域</li>
<li>块作用域</li>
<li>函数原型作用域</li>
</ul>
<h2 id="函數"><a href="#函數" class="headerlink" title="函數"></a>函數</h2><ol>
<li>一个函数就是一个功能</li>
<li>函数包括:</li>
</ol>
<ul>
<li>系统函数(库函数)</li>
<li>用户自己定义的函数(无参函数,有参函数)<h3 id="函數的原則"><a href="#函數的原則" class="headerlink" title="函數的原則"></a>函數的原則</h3></li>
</ul>
<ol>
<li>函数不可以被嵌套定义:函数内部不可以再次定义新的函数</li>
<li>函数可以通过原型完成有默认参数的函数</li>
<li>函数是先定义后使用，具体是指上下文环境</li>
<li>Runtime Environment在C++中是使用Stack<h3 id="函數模板"><a href="#函數模板" class="headerlink" title="函數模板"></a>函數模板</h3></li>
<li><code>template &lt;typename T&gt;</code></li>
<li>T max(T a,T b, T c){}</li>
<li>在运行时确定T的类型<h3 id="函數編譯鏈接"><a href="#函數編譯鏈接" class="headerlink" title="函數編譯鏈接"></a>函數編譯鏈接</h3></li>
<li>只編譯當前模块<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">g</span>()&#123;<span class="comment">//a.cpp</span></span><br><span class="line">  <span class="built_in">f</span>();<span class="comment">//b.cpp</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>编译每个编译单元<code>.cpp</code>时是相互独立的，即每个cpp文件之间是不知道对方的存在的,.cpp编译成<code>.obj</code>后，link时時a.obj才会从b.obj中获得<code>f()</code>函数的信息。</li>
<li>link时将编译的结果连接成可执行代码，主要是确定各部分的地址,将编译结果中的<code>地址符号全换成实地址</code>(call指令在a.cpp被编译时只是call f的符号，而不知道f确切的地址)<h3 id="重載-Overloading-重寫-Overriding"><a href="#重載-Overloading-重寫-Overriding" class="headerlink" title="重載(Overloading)重寫(Overriding)"></a>重載(Overloading)重寫(Overriding)</h3>overload是C++中的一種語法特性，它允許定義多個同名函數，只要這些函數的參數列表不同，就可以通過自動類型轉換來選擇合適的函數來調用。overload有助于提高程序的代碼可讀性和可維護性，同時也提供了更多的程序寫作選擇。</li>
</ol>
<p>例如，下面的代碼定義了三個同名的函數max，分別接收不同數量的參數，這三個函數都可以通過overload特性來調用：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">max</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> x &gt; y ? x : y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">max</span><span class="params">(<span class="type">double</span> x, <span class="type">double</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> x &gt; y ? x : y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">max</span><span class="params">(<span class="type">double</span> x, <span class="type">double</span> y, <span class="type">double</span> z)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">max</span>(<span class="built_in">max</span>(x, y), z);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>原則:</p>
<ol>
<li>名稱相同，參數不同(函数的参数个数、参数类型、参数顺序至少一个不同)</li>
<li>返回值不作為區別重載函數的依據</li>
</ol>
<p>overriding是一種面向對象編程中的概念，指的是在子類中重寫父類中的方法或函數。這種操作可以使得子類對父類中的方法或函數進行修改和擴展，提高程序的靈活性和可重用性。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//例如，假設有一個基礎類Base，包含一個方法Print，代碼如下：</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Print</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Base::Print&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//接下來我們定義一個子類Derived，繼承自Base類，並重寫了Print方法，代碼如下：</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">public</span> Base</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Print</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Derived::Print&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h3 id="函數的默認參數"><a href="#函數的默認參數" class="headerlink" title="函數的默認參數"></a>函數的默認參數</h3><ol>
<li>默认参数的声明:默认参数是严格从右至左的顺序使用的</li>
</ol>
<ul>
<li>在函数原型中给出</li>
<li>先定义的函数中给出</li>
<li>不間斷</li>
<li>在定义中一般不给出默认参数，在调用的时候使用函数原型的时候给出默认参数</li>
</ul>
<ol>
<li>函数默认重载，在面向对象编程中，子类即便修改默认参数，也不生效。</li>
</ol>
<h3 id="外部函數-extern"><a href="#外部函數-extern" class="headerlink" title="外部函數 extern"></a>外部函數 extern</h3><ol>
<li>符号表:Name mangling: extern “C”</li>
</ol>
<ul>
<li>在C++的g中调用C中的f，会在link的时候出问题(因为不在C++ 的符号表中)</li>
<li>解决方案:在函数名前面加上extern的关键词(这样子编译器就会在编译过程中从外部进行寻找)</li>
</ul>
<ol>
<li>C编译器编译的文件被放置在lib库中，C++不能直接调用，而是需要extern才可以</li>
<li>符号表：与编译的各个阶段都有交互，存有函数名、地址等信息；编译时会创建一个函数符号表<name,address>，对应的符号后面的地址还没确定(link期决定)，call name根据name找到符号表对应的地址，再执行</li>
<li>对于c语言来说，编译得到的符号表内函数f在符号表里的name就是f(不存在函数重载)</li>
<li>对于c++来说，因为有重载，所以f(int)和f(float)在符号表里的name是不同的</li>
<li>c++对于c语言的函数f会按c++的方式生成函数表中的nameA，但c编译好的函数表内f对应的nameB和nameA不一致，导致c++无法找到该函数</li>
</ol>
<h3 id="函數與內存"><a href="#函數與內存" class="headerlink" title="函數與內存"></a>函數與內存</h3><p>函數是使用<code>臨時性存儲空間</code></p>
<ol>
<li>空間從上往下分別是:</li>
</ol>
<ul>
<li>code: 每个指令都有对应的单元地址。函数的代码存放的位置是受到限制的</li>
<li>Data:存放数据(局部变量和全局变量)</li>
<li>Stack:由系统管理，存放函数</li>
<li>Heap:可以用程序员进行分配，可以在运行时动态确定，C中使用<code>int *p = (int *)malloc(4)</code>，归还内存<code>free</code>(C++中就不要使用这种方法进行处理，而是使用new和delete)</li>
</ul>
<ol>
<li>RunTime Environment</li>
<li>每一个函数都有栈空间，被称为frame(active frame是当前运行函数的栈空间)</li>
<li>棧空間: 是从高地址向低地址生长，栈底:ebp(当前函数的存取指针，即存储或者读取数时的指针基地址)<br>栈顶:esp(当前函数的栈顶指针)，保存:返回地址、调用者的基指针。<span class="bubble-content">過程描述</span><span class="bubble-notation"><span class="bubble-item" style="background-color:#71a4e3;">过程描述:调用一个函数时，先将堆栈原先的基址(ebp)入栈，以保存之前任务的信息。然后将栈顶指针的值赋给ebp，将之前的栈顶作为新的基址(栈底)，然后在这个基址上开辟相应的空间用作被调用函数的堆栈。函数返回后，从ebp中可取出之前的esp值，使栈顶恢复函数调用前的位置；再从恢复后的栈顶可弹出之前的EBP值，因为这个值在函数调用前一步被压入堆栈。这样，EBP和ESP就都恢复了调用前的位置，堆栈恢复函数调用前的状态。</span></span>
<img src="https://s2.loli.net/2022/12/08/7T1UFxKqW3bdJi2.png" alt="棧.png"><h3 id="參數傳递"><a href="#參數傳递" class="headerlink" title="參數傳递"></a>參數傳递</h3></li>
<li>call by value(值傳递，C、C++支持)<br><img src="https://s2.loli.net/2022/12/08/ao8Cr4mQnTHwsND.png" alt="C++值傳递.png"><details class="folding-tag" yellow><summary> 函數調用過程 </summary>
              <div class='content'>
              <ol><li>开始调用esp从栈顶向下移动32位，存ret_addr，开辟main函数的栈空间</li><li>然后esp继续向下存ebp_main</li><li>然后ebp到esp处</li><li>然后esp到新的函数空间的栈顶</li><li>函数处理</li><li>esp先返回到ebp</li><li>然后ebp根据ebp_main返回，然后esp加一(向上)</li><li>之后esp回到ret_addr位置即可。<div class="tip bell"><p>为什么ebp和esp之间距离很大，因为我们要对齐，提高内存管理效率</p></div></li></ol>
              </div>
            </details></li>
<li>call by reference(引用傳递,C++支持)<br>傳递的是地址，會同時修改對應地址單元中的值<br><img src="https://s2.loli.net/2022/12/08/e6Ds7tEhnzrb3AF.png" alt="C++引用傳递.png"></li>
<li>call by name<br>指在用到该参数的时候才会计算参数表达式的值，將參數的名稱（即變量名）作為參數傳遞給函數，而不是參數的值，效率較低。</li>
</ol>
<h3 id="函數調用過程總結"><a href="#函數調用過程總結" class="headerlink" title="函數調用過程總結"></a>函數調用過程總結</h3><ol>
<li>加载参数(进栈)</li>
<li>保存上下文环境</li>
</ol>
<ul>
<li>保存返回地址</li>
<li>保存调用者基指针</li>
</ul>
<ol>
<li>执行函数</li>
</ol>
<ul>
<li>设置新的基指针</li>
<li>分配空间(可选)</li>
<li>执行一些任务</li>
<li>释放空间(如果分配了的话)</li>
</ul>
<ol>
<li>恢复上下文环境</li>
</ol>
<ul>
<li>加载调用者基指针</li>
<li>加载返回指针</li>
</ul>
<ol>
<li>继续执行调用者的功能</li>
</ol>
<h3 id="內聯函數inline"><a href="#內聯函數inline" class="headerlink" title="內聯函數inline"></a>內聯函數inline</h3><ol>
<li>目的:</li>
</ol>
<ul>
<li>提高可读性</li>
<li>提高效率</li>
<li>解决了两个cost的问题</li>
</ul>
<ol>
<li>对象:使用频率高、简单、小段代码</li>
<li>实现方法:编译系统将为inline函数创建一段代码，在每次调用时，用相应的代码替换</li>
<li>限制：</li>
</ol>
<ul>
<li>必须是非递归函数,因为已经加入主体部分了</li>
<li>由编译系统控制,和编译器是完全相关的</li>
</ul>
<ol>
<li>内联必须和函数体放在一起，而不是和原型放在一起，并且函数体必须出现在调用之前，否则函数可以编译，但是不出现内联。</li>
</ol>
<h2 id="輸入輸出"><a href="#輸入輸出" class="headerlink" title="輸入輸出"></a>輸入輸出</h2><p>輸入輸出流包含在頭文件<code>&lt;iostream&gt;</code>中<br>標準庫對象:</p>
<ul>
<li>istream:cin: 处理输入</li>
<li>ostream:cout: 处理输出</li>
<li>ostream:cerr: 处理错误</li>
<li>ostream:clog: 保证log<h3 id="輸入"><a href="#輸入" class="headerlink" title="輸入"></a>輸入</h3></li>
</ul>
<ol>
<li>原理:</li>
</ol>
<ul>
<li>程序的输入都键入一个缓冲区，即输入缓冲区。</li>
<li>键盘输入结束后，会将数据存入缓冲区，之后cin函数直接从输入缓冲区取数据</li>
<li>问题在于:缓冲区中有残留数据的时候，cin输入流直接从缓冲区拿数据。</li>
</ul>
<ol>
<li>cin</li>
</ol>
<ul>
<li><code>&gt;&gt;</code>是流提取符，以空格，\t(Tab),\n(回车)为终止</li>
<li>往往使用来赋值给变量</li>
</ul>
<ol>
<li>數組輸入<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span> ; i &lt; n ;i++)&#123;</span><br><span class="line">  cin &gt; nums[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//未知長度數組讀入</span></span><br><span class="line"><span class="keyword">while</span>(cin &gt;&gt; n)&#123;<span class="comment">//如果沒有數字輸入則會為NULL</span></span><br><span class="line">  nums[i] = n;</span><br><span class="line">  i++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>cin.get()方法</li>
</ol>
<ul>
<li>结束符默认为enter，结束字符串的读写</li>
<li>字符串最后一个为\0，并且对空格不敏感。</li>
<li>get方法并<code>不会</code>将结束符从缓冲区丢弃，务必注意是结束符，未必是回车。<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//按照字符读取</span></span><br><span class="line">cin.<span class="built_in">get</span>(x);</span><br><span class="line">cin.<span class="built_in">get</span>(y);<span class="comment">//\n也可以读取到</span></span><br><span class="line"><span class="comment">//cin.get == c语言中的getchar()</span></span><br><span class="line"><span class="comment">//按照字符串读取</span></span><br><span class="line"><span class="type">char</span> ch1,ch2[<span class="number">10</span>];</span><br><span class="line">cout&lt;&lt;<span class="string">&quot;请输入字符串:&quot;</span>&lt;&lt;endl;</span><br><span class="line">cin.<span class="built_in">get</span>(ch2,<span class="number">6</span>);<span class="comment">//在不遇到结束符的情况下，最多可接收6-1=5个字符到ch2中，注意结束符为默认Er</span></span><br><span class="line">cin.<span class="built_in">get</span>(ch1);<span class="comment">//或ch1 = cin.get();</span></span><br><span class="line">out&lt;&lt;ch2&lt;&lt;end1:</span><br><span class="line">cout&lt;&lt;ch1&lt;&lt;<span class="string">&quot;n&quot;</span>&lt;&lt;(<span class="type">int</span>)chi&lt;&lt;endl;</span><br></pre></td></tr></table></figure>
直接回车在上面程序中会出现错误输出(越界)，处理方法<code>cin.clear()</code>:但是不会清理终止符</li>
</ul>
<ol>
<li>cin.getline()</li>
</ol>
<ul>
<li>cin.getline(字符数组名,接收长度，结束符)</li>
<li>cin.get()超长后不会影响cin的操作，而cin.getline()如果超长会导致之后cin的错误</li>
</ul>
<ol>
<li>getline()</li>
</ol>
<ul>
<li>getline(istream is,string str,结束符)<br><code>getline(cin,str);</code></li>
</ul>
<ol>
<li>cin.ignore()<br>刪除緩冲区第一個字符<br><code>cin.ignore(1024,&#39;\n);cin.ignore(std::numeric_limits&lt;std::streamsize&gt;::max(), &#39;\n&#39;);</code>清除緩冲区</li>
<li>getchar()/putchar()<br>函數輸入輸出，獲得(可以讀到空間,<code>\n</code>等等)/輸出一個字符</li>
</ol>
<h3 id="輸出"><a href="#輸出" class="headerlink" title="輸出"></a>輸出</h3><p>1.標准輸出流cout</p>
<ul>
<li>&lt;&lt;流插入符</li>
<li><code>std::endl</code>換行，等價於<code>\n</code></li>
<li>格式化輸出</li>
<li>using namespace std 來直接使用</li>
</ul>
<h3 id="重定向"><a href="#重定向" class="headerlink" title="重定向"></a>重定向</h3><p>C++的輸入輸出重定向是指讓程式可以從不同的來源讀取輸入並將輸出寫入到不同的位置。這通常可以通過使用C++中的輸入輸出流（如std::cin和std::cout）和重定向符號來實現。</p>
<p>例如，假設您有一個名為my_program.cpp的C++程式，並且想要將它的輸入重定向到一個名為input.txt的文件，並將它的輸出重定向到一個名為output.txt的文件。您可以使用以下命令來實現這一點：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$my_program</span>.exe &lt; input.txt &gt; output.txt</span><br></pre></td></tr></table></figure><br>在這個例子中，my_program.exe是從my_program.cpp編譯得到的可執行文件，&lt; input.txt表示將input.txt文件的輸入重定向到my_program.exe，&gt; output.txt表示將my_program.exe的輸出重定向到output.txt文件。</p>
<p>另外，您還可以使用重定向符號來將多個文件的輸入或輸出鏈接在一起，以實現更高級的重定向功能。例如，假設想要將一個文件的輸出直接作為另一個文件的輸入，可以使用以下命令實現：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$my_program</span>.exe &lt; input1.txt | my_program2.exe &gt; output.txt</span><br></pre></td></tr></table></figure><br>另外，還可以使用重定向符號來將一個文件的輸入和輸出重定向到同一個位置。例如，假設想要將一個文件的輸入和輸出都重定向到終端機，可以使用以下命令實現：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ my_program.exe &lt; input.txt | <span class="built_in">tee</span> output.txt</span><br></pre></td></tr></table></figure></p>
<h3 id="文件讀寫"><a href="#文件讀寫" class="headerlink" title="文件讀寫"></a>文件讀寫</h3><p>C++提供了一種叫做fstream的類，它可以讓您讀寫文件。fstream類提供了三個子類，分別是<code>ifstream</code>，<code>ofstream</code>和<code>fstream</code>，它們分別用於讀取文件，寫入文件和讀寫文件。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 創建一個fstream對象</span></span><br><span class="line">  fstream file;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 以讀寫模式打開文件</span></span><br><span class="line">  file.<span class="built_in">open</span>(<span class="string">&quot;my_file.txt&quot;</span>, ios::in | ios::out);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 如果文件無法打開，則輸出錯誤信息</span></span><br><span class="line">  <span class="keyword">if</span> (!file) &#123;</span><br><span class="line">    std::cerr &lt;&lt; <span class="string">&quot;Error: unable to open file&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 從文件中讀取一個字符串</span></span><br><span class="line">  std::string line;</span><br><span class="line">  <span class="built_in">getline</span>(file, line);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 將字符串輸出到終端機</span></span><br><span class="line">  std::cout &lt;&lt; line &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 從終端機讀取一個字符串</span></span><br><span class="line">  std::string input;</span><br><span class="line">  std::cin &gt;&gt; input;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 將字符串寫入文件</span></span><br><span class="line">  file &lt;&lt; input &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 關閉文件</span></span><br><span class="line">  file.<span class="built_in">close</span>();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>需要注意的是，在讀寫文件時，需要小心檢查文件是否打開成功，並避免對未打開的文件進行操作。此外，還需要在完成讀寫操作後關閉文件，以防止文件被意外修改或者損壞。</p>
<h2 id="指針和引用"><a href="#指針和引用" class="headerlink" title="指針和引用"></a>指針和引用</h2><p>C++的指針是一種特殊的變量，它保存了一個值的位址。指針可以用來訪問該位址中的數據，並能夠實現更加靈活的程序設計。</p>
<ol>
<li>定义:<code>&lt;基类型&gt;*&lt;指针变量&gt;:void*</code>:可以作为所有指针的接口，void的指针类型可以被赋值为任何类型的指针。<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">9</span>;</span><br><span class="line"><span class="type">int</span>* p = &amp;a;<span class="comment">//指向同一地址</span></span><br><span class="line"><span class="type">int</span>* q = p;</span><br><span class="line">*p = <span class="number">8</span>;</span><br><span class="line"><span class="type">void</span>* p1 = p;</span><br><span class="line"><span class="type">double</span>*<span class="number">91</span>;</span><br><span class="line">p1 = q1;<span class="comment">//是允许的</span></span><br></pre></td></tr></table></figure></li>
<li>使用typedef来定义一个指针类型(别名)<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">int</span>* Pointer;</span><br><span class="line">Pointer p,q;</span><br></pre></td></tr></table></figure></li>
<li>可以直接进行赋值:因为C++可以进行系统开发，所以一定是可以操作绝对地址的</li>
</ol>
<h3 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h3><ol>
<li>取地址:<code>&amp;</code></li>
<li>間接取內容:<code>*</code></li>
<li>所有的指针都要初始化</li>
</ol>
<ul>
<li>C++会初始化指针为0(默认初始化)，如果编译器发现指向为0，则报错，因为0地址是保留空间</li>
<li>不允許<code>char *p = (void*)</code></li>
<li>引入了nullptr:作为不依赖任何值的指针</li>
</ul>
<ol>
<li>同類型賊值</li>
<li>加減</li>
</ol>
<ul>
<li>sizeof(基類型)* 整形數值</li>
</ul>
<ol>
<li>比較(==/!=)</li>
<li>void* 是指針類型的公共接口</li>
<li>可用來將某块內存清零</li>
<li>memset()通常用來為申請內存進行初始化操作</li>
</ol>
<ul>
<li>函數原型<code>memset(void *s,int ch,size_t n);</code><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> my_array[<span class="number">10</span>];</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 使用memset將my_array中的所有元素設置為0</span></span><br><span class="line">  <span class="built_in">memset</span>(my_array, <span class="number">0</span>, <span class="built_in">sizeof</span>(my_array));</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 輸出my_array中的所有元素</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">    std::cout &lt;&lt; my_array[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  std::cout &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="常量指針與指針常量"><a href="#常量指針與指針常量" class="headerlink" title="常量指針與指針常量"></a>常量指針與指針常量</h3><ol>
<li>常量指針</li>
</ol>
<ul>
<li><code>const &lt;類型&gt;* &lt;指針變量&gt;</code></li>
<li>不可以修改指針指向單元的內部的值</li>
<li>用来消除函数的副作用，保证在函数端中只读数据<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> c = <span class="number">0</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> *cp;</span><br><span class="line"><span class="type">int</span> y = <span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> *q;</span><br><span class="line">cp = &amp;c; v<span class="comment">//cp 可以指向 c</span></span><br><span class="line">q = &amp;y; v<span class="comment">//q 可以指向 y</span></span><br><span class="line">*cp = <span class="number">1</span> ; x<span class="comment">//*cp 是一个常量,不可以赋值</span></span><br><span class="line">*q = <span class="number">2</span> ; v<span class="comment">//变量指针可以指向变量</span></span><br><span class="line">cp = &amp;y; v<span class="comment">//常量指针可以指向变量，传递的是y的空间，并且对于y的这个空间只是可读的，安全的= &amp;c; x//不可以的，因为g的修改可以间接修改c，所以编译器不允许</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(<span class="type">int</span> *p)</span></span>&#123;</span><br><span class="line">  cout &lt;&lt; *p &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> c = <span class="number">8</span>;</span><br><span class="line"><span class="built_in">print</span>(c) ;<span class="comment">//不可以被调用的</span></span><br><span class="line"><span class="built_in">print</span>(&amp;c);<span class="comment">//C++赋给的权利，在调用的时候除去常量的特性，这个&amp;是强制类型转换，取消常量特性</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(<span class="type">const</span> <span class="type">int</span> *p)</span></span>&#123;<span class="comment">//如此修改就可以大量复用/常量使用者和变量使用者都可以使用</span></span><br><span class="line">  cout &lt;&lt; *p &lt;&lt; endl:</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>面向對象中没有const會帶來很大的訪問權限的問題</li>
</ul>
<ol>
<li>指針常量</li>
</ol>
<ul>
<li><code>&lt;類型&gt;* const&lt;指針變量&gt;</code></li>
<li>在定義時初始化<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> x,y;</span><br><span class="line"><span class="type">int</span> *cons p = &amp;x;<span class="comment">//p始終如一的指向x單元，這個單元是可變的</span></span><br><span class="line">p = &amp;y;<span class="comment">//錯的</span></span><br></pre></td></tr></table></figure></li>
<li>const int * const p是非常強的指針約束<h3 id="指針與函數"><a href="#指針與函數" class="headerlink" title="指針與函數"></a>指針與函數</h3></li>
</ul>
<ol>
<li>指針作為形參</li>
</ol>
<ul>
<li>提高传输效率</li>
<li>函数副作用</li>
<li>常量指针</li>
</ul>
<ol>
<li>函數指針<br>函數指針是一種特殊的指針，它指向一個函數。函數指針可以用來實現更加灵活的程序设计，并能够实现函数的动态调用。<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">my_func</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 创建一个指向my_func的函数指针</span></span><br><span class="line">  <span class="built_in">int</span> (*my_pointer)(<span class="type">int</span>, <span class="type">int</span>) = &amp;my_func;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 通过指针调用函数</span></span><br><span class="line">  <span class="type">int</span> result = (*my_pointer)(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">  std::cout &lt;&lt; result &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
计算一元函数在某区间上的定积分<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;math.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">integrate</span><span class="params">(<span class="type">double</span> (*f)(<span class="type">double</span>),<span class="type">double</span> a, <span class="type">double</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123; … <span class="built_in">f</span>(x),  a ,  b, …  &#125;</span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">my_func</span><span class="params">(<span class="type">double</span> x)</span></span>&#123; … &#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">integrate</span>(sin,<span class="number">0</span>,<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">integrate</span>(cos,<span class="number">1</span>,<span class="number">2</span>);</span><br><span class="line">    <span class="built_in">integrate</span>(my_func,<span class="number">1</span>,<span class="number">10</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="數組"><a href="#數組" class="headerlink" title="數組"></a>數組</h3><ol>
<li>一維數組</li>
</ol>
<ul>
<li><code>*(p+i)</code>p不移動</li>
<li><code>*(p++)</code>p移動</li>
<li><code>int *p = a</code>a表示的是數組首地址，傳递的是<code>int *const</code>，a[0]可以寫為p[0]</li>
<li>sizeof(a)就是數組整個块大小</li>
</ul>
<ol>
<li>二組數組</li>
</ol>
<ul>
<li>用一維方式訪問</li>
<li><code>int *p = &amp;a[0][0]</code>p指向的是T類型<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; <span class="number">12</span>;i++)&#123;</span><br><span class="line">    *(p++) = <span class="number">9</span>;<span class="comment">//越界了(对应一维数组的越界)，但是二维数组没有越界</span></span><br><span class="line">&#125;</span><br><span class="line">######################################<span class="meta">#</span></span><br><span class="line"><span class="meta">typedef int T[2];   </span></span><br><span class="line">T a[<span class="number">6</span>];<span class="comment">//int a[6][2]</span></span><br><span class="line">T *q = a;</span><br><span class="line"><span class="comment">//不使用T的方法</span></span><br><span class="line"><span class="type">int</span>[<span class="number">2</span>] *q;</span><br></pre></td></tr></table></figure></li>
</ul>
<ol>
<li>數組元素操作<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a[<span class="number">10</span>];</span><br><span class="line"><span class="built_in">sizeof</span>(a);<span class="comment">//数组大小</span></span><br><span class="line"><span class="built_in">sizeof</span>(a+<span class="number">1</span>);<span class="comment">//内存地址的长度，单位bytes</span></span><br><span class="line"><span class="type">int</span> *p;</span><br><span class="line"><span class="type">int</span> i=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">p = &amp;a[<span class="number">0</span>] == p = a;    </span><br><span class="line"></span><br><span class="line">a[i] == *(a+i) == *(p+i) == p[i]</span><br><span class="line">&amp;a[i] == a+i == p+i == &amp;p[i]</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> b[<span class="number">20</span>][<span class="number">10</span>];</span><br><span class="line"><span class="comment">//等价于</span></span><br><span class="line"><span class="comment">//typedef int T[10];</span></span><br><span class="line"><span class="comment">//T b[20];</span></span><br><span class="line"><span class="type">int</span> *q;</span><br><span class="line">q = &amp;b[<span class="number">0</span>][<span class="number">0</span>];<span class="comment">// q = b[0]</span></span><br><span class="line"><span class="comment">//b[i][j] == *(&amp;b[0][0] + i*10 + j) == *(q + i * 10 + j) == q[i*10 + j]</span></span><br><span class="line">T * p;<span class="comment">//int (*p)[10];</span></span><br><span class="line">p = &amp;b[<span class="number">0</span>];<span class="comment">// p = b</span></span><br><span class="line"><span class="comment">//b[i][j] == *(*(b+i)+j) == *(*(p+i)+j) == p[i][j]</span></span><br></pre></td></tr></table></figure></li>
</ol>
<ul>
<li>降維操作<br>越界操作:C++认为是允许的，只要这块内存空间在我们的控制范围内即可<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span>  <span class="title">maximum</span><span class="params">(<span class="type">int</span> a[], <span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> max = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">0</span>;k&lt;n;k++)</span><br><span class="line">        <span class="keyword">if</span> (a[k] &gt; max)</span><br><span class="line">      max = a[k];  </span><br><span class="line">  <span class="keyword">return</span> max;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span>  A[<span class="number">2</span>][<span class="number">4</span>] = &#123; &#123;<span class="number">68</span>,<span class="number">69</span>,<span class="number">70</span>,<span class="number">71</span>&#125; , &#123;<span class="number">85</span>,<span class="number">86</span>,<span class="number">87</span>,<span class="number">89</span>&#125;&#125;;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;the max grade is&quot;</span> &lt;&lt; <span class="built_in">maximum</span>(A[<span class="number">0</span>],<span class="number">2</span>*<span class="number">4</span>);<span class="comment">//maximum(&amp;A[0][0],2*4) =&gt;maximum(&amp;A[0][0],sizeof(A)/sizeof(A[0][0]))</span></span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure></li>
<li>升維操作(重要)<br>因为申请内存空间的时候只能申请到线性部分<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">show</span><span class="params">(<span class="type">int</span> a[],  <span class="type">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)  &#123;</span><br><span class="line">        cout &lt;&lt; a[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        cout &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">show</span><span class="params">(<span class="type">int</span> a[][<span class="number">2</span>], <span class="type">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)  </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j=<span class="number">0</span>;j&lt;<span class="number">2</span>;j++) &#123;</span><br><span class="line">            cout &lt;&lt; a[i][j] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">            cout &lt;&lt; *(a+i)+j &lt;&lt; <span class="string">&quot; :&quot;</span> &lt;&lt; a[i][j] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">            <span class="comment">//四个换一行</span></span><br><span class="line">            <span class="keyword">if</span> ((i*<span class="number">2</span>+j+<span class="number">1</span>)%<span class="number">4</span> == <span class="number">0</span>)</span><br><span class="line">                cout &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">show</span><span class="params">(<span class="type">int</span> a[][<span class="number">2</span>][<span class="number">3</span>], <span class="type">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)  </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j=<span class="number">0</span>;j&lt;<span class="number">2</span>;j++)</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> k=<span class="number">0</span>;k&lt;<span class="number">3</span>;k++)&#123;</span><br><span class="line">                cout &lt;&lt; a[i][j][k] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">                cout &lt;&lt; *(*(a+i)+j)+k &lt;&lt; <span class="string">&quot; :&quot;</span> &lt;&lt; a[i][j][k] &lt;&lt; <span class="string">&quot;  &quot;</span>;</span><br><span class="line">                <span class="comment">//换行输出</span></span><br><span class="line">                <span class="keyword">if</span> ((i*<span class="number">6</span>+j*<span class="number">3</span>+k+<span class="number">1</span>)%<span class="number">4</span> == <span class="number">0</span>)</span><br><span class="line">                    cout &lt;&lt; endl;</span><br><span class="line">            &#125;</span><br><span class="line">  cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> b[<span class="number">12</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">12</span>;i++)  b[i] = i+<span class="number">1</span>;</span><br><span class="line">    <span class="built_in">show</span>(b,<span class="number">12</span>);</span><br><span class="line">    <span class="comment">//二维数组</span></span><br><span class="line">    <span class="keyword">typedef</span> <span class="type">int</span> T[<span class="number">2</span>];</span><br><span class="line">    <span class="built_in">show</span>((T*)b,<span class="number">6</span>);<span class="comment">//show((int (*)[2])b,6),一定有括号</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//三维数组</span></span><br><span class="line">    <span class="keyword">typedef</span> <span class="type">int</span> T1[<span class="number">3</span>];</span><br><span class="line">    <span class="keyword">typedef</span> T1 T2[<span class="number">2</span>];</span><br><span class="line">    <span class="built_in">show</span>((T2*)b,<span class="number">2</span>);<span class="comment">//show((int (*)[2][3])b,2)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<ol>
<li>指針數組<br>數組中的元素為指針<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> *s1[] = &#123;<span class="string">&quot;C++&quot;</span>, <span class="string">&quot;PASCAL&quot;</span>, <span class="string">&quot;FORTRAN&quot;</span>&#125;;</span><br><span class="line"><span class="type">char</span> s2[][<span class="number">8</span>] = &#123;<span class="string">&quot;C++&quot;</span>, <span class="string">&quot;PASCAL&quot;</span>, <span class="string">&quot;FORTRAN&quot;</span>&#125;;</span><br></pre></td></tr></table></figure>
<img src="https://s2.loli.net/2022/12/09/kWcaOl37Dnms16T.png" alt="指針數組.png"></li>
</ol>
<h3 id="多級指針"><a href="#多級指針" class="headerlink" title="多級指針"></a>多級指針</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">myswap</span><span class="params">(<span class="type">int</span> *p1, <span class="type">int</span> *p2)</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span>* tmp = p1;</span><br><span class="line">  p1 = p2;</span><br><span class="line">  p2 = tmp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">myswap2</span><span class="params">(<span class="type">int</span> &amp;p1, <span class="type">int</span> &amp; p2)</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> tmp = p1;</span><br><span class="line">  p1 = p2;</span><br><span class="line">  p2 = tmp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">myswap</span><span class="params">(<span class="type">char</span> **p1, <span class="type">char</span> **p2)</span> </span>&#123;</span><br><span class="line">  <span class="type">char</span> *tmp = *p1;</span><br><span class="line">  *p1 = *p2;</span><br><span class="line">  *p2 = tmp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">char</span> *p1 =(<span class="type">char</span>*) <span class="string">&quot;abcd&quot;</span>;</span><br><span class="line">  <span class="type">char</span> *p2 =(<span class="type">char</span>*) <span class="string">&quot;1234&quot;</span>;</span><br><span class="line">  <span class="type">int</span> a = <span class="number">100</span>;</span><br><span class="line">  <span class="type">int</span> b = <span class="number">200</span>;</span><br><span class="line">  <span class="built_in">myswap</span>(&amp;a, &amp;b);</span><br><span class="line">  cout &lt;&lt; a &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; b &lt;&lt; endl;<span class="comment">//100 200</span></span><br><span class="line">  <span class="built_in">myswap2</span>(a, b);</span><br><span class="line">  cout &lt;&lt; a &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; b &lt;&lt; endl;<span class="comment">//200 100</span></span><br><span class="line">  <span class="built_in">myswap</span>(&amp;p1, &amp;p2);</span><br><span class="line">  cout &lt;&lt; p1 &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; p2 &lt;&lt; endl;<span class="comment">//1234 abcd</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="動態變量"><a href="#動態變量" class="headerlink" title="動態變量"></a>動態變量</h3><ol>
<li>动态:大小、生命周期</li>
<li>非编译时刻确定</li>
<li>是在heap中申请存储空间</li>
<li>申請: <code>new &lt;類型名&gt; [&lt;整型表逹式&gt;]</code></li>
<li>分配連續空間<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//---------------------------------------</span></span><br><span class="line"><span class="type">int</span> *p = <span class="keyword">new</span> <span class="type">int</span>[<span class="number">10</span>];<span class="comment">//分配一块连续空间</span></span><br><span class="line"><span class="type">int</span> *p = (<span class="type">int</span>*)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(<span class="type">int</span>)*<span class="number">10</span>)</span><br><span class="line"><span class="built_in">int</span> (*p2)[<span class="number">5</span>] = (<span class="built_in">int</span> (*)[<span class="number">5</span>])p;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)</span><br><span class="line">    p[i] = i+<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">q = <span class="keyword">new</span> <span class="type">int</span>[<span class="number">2</span>][<span class="number">5</span>];<span class="comment">//错误的，没有这种写法</span></span><br><span class="line"><span class="comment">//想用二维数组访问，升维操作</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j=<span class="number">0</span>;j&lt;<span class="number">2</span>;j++)</span><br><span class="line">&#123;   <span class="keyword">for</span> (<span class="type">int</span> k=<span class="number">0</span>;k&lt;<span class="number">5</span>;k++)</span><br><span class="line">        cout &lt;&lt; p2[j][k] &lt;&lt; <span class="string">&quot;   &quot;</span>;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//---------------------------------------</span></span><br><span class="line"><span class="comment">//多维数组使用构造数据类型申请内存</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> i5Array [<span class="number">5</span>];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    i5Array *p = <span class="keyword">new</span> i5Array [<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j=<span class="number">0</span>;j&lt;<span class="number">2</span>;j++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> k=<span class="number">0</span>;k&lt;<span class="number">5</span>;k++)</span><br><span class="line">            p[j][k] = (j*<span class="number">5</span>)+(k+<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>面向對象中的new關鍵字<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//---------------------------------------</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line"></span><br><span class="line">A *p = <span class="keyword">new</span> A;<span class="comment">//调用默认构造函数</span></span><br><span class="line">A *p = (A*) <span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(A));<span class="comment">//只是分配空间</span></span><br><span class="line"><span class="comment">//---------------------------------------</span></span><br><span class="line"><span class="keyword">namespace</span> std&#123;<span class="comment">//处理内存</span></span><br><span class="line">    <span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(*new_handler)</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">new_handler <span class="title">set_new_handler</span><span class="params">(new_handler p)</span> <span class="title">throw</span><span class="params">()</span></span>;</span><br><span class="line">&#125;<span class="comment">//不满意应对，我们可以重载方法来处理</span></span><br></pre></td></tr></table></figure></li>
<li>歸還動態變量</li>
</ol>
<ul>
<li>delete(调用数组内第一个对象的析构函数)|delete[] (调用数组内所有的对象的析构函数)</li>
<li>空間都會被歸還</li>
<li>析构函数:不仅仅是归还自己的内存，还有窗口资源和文件等东西归还掉</li>
</ul>
<ol>
<li>動態變量的應用</li>
</ol>
<ul>
<li>數據結構:链表(单、双)、栈、队列、树、图<br>鏈表結點定義<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">NODE</span>&#123;</span><br><span class="line">    <span class="type">int</span>  content;</span><br><span class="line">    NODE *next;</span><br><span class="line">&#125;;</span><br><span class="line">NODE *head=<span class="literal">NULL</span>;<span class="comment">//使用头结点</span></span><br></pre></td></tr></table></figure></li>
<li>具体应用：硬盘上的文件存放:一种实现是单链表(文件分配表FAT:用来存储数据的开始的位置。FAT一旦被破坏就导致所有的数据丢失)</li>
</ul>
<ol>
<li>引用<br>为一块已有的内存空间取一个别名，引用变量和被引用变量，必须是同类型，引用变量定义中的&amp;不是取地址操作符，定义引用变量时，必须初始化<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> &amp;a = *p;<span class="comment">//一旦是p的别名，就一定只能是p的别名了</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(<span class="type">int</span> &amp;a)</span><span class="comment">//利用函数副作用</span></span></span><br></pre></td></tr></table></figure></li>
</ol>
<ul>
<li>应用:函數參數傳递，動態變量命名</li>
<li>函數返回值為指針或引用<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">max1</span><span class="params">(<span class="type">int</span> x[], <span class="type">int</span> num)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> m,i;</span><br><span class="line">    m = x[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">1</span>; i&lt;num; i++)</span><br><span class="line">        <span class="keyword">if</span> (x[i] &gt; m) m = x[i];</span><br><span class="line">    <span class="keyword">return</span> m;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> &amp;<span class="title">max3</span><span class="params">(<span class="type">int</span> x[], <span class="type">int</span> num)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> i, j;</span><br><span class="line">    j = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">1</span>; i&lt;num; i++)</span><br><span class="line">       <span class="keyword">if</span> (x[i] &gt; x[j]) j = i;</span><br><span class="line">    <span class="keyword">return</span> x[j];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> *<span class="title">max2</span><span class="params">(<span class="type">int</span> x[], <span class="type">int</span> num)</span></span>&#123;</span><br><span class="line">    <span class="comment">//返回的指针</span></span><br><span class="line">    <span class="type">int</span> *p,*q;</span><br><span class="line">    p = x;</span><br><span class="line">    q = x+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (num &gt; <span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span> (*q &gt; *p) p = q;</span><br><span class="line">        q++; num--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> A[<span class="number">16</span>];<span class="comment">//操作的是调用者的空间的部分</span></span><br><span class="line">    cout &lt;&lt; <span class="built_in">max1</span>(A,<span class="number">16</span>);</span><br><span class="line">    cout &lt;&lt; <span class="built_in">max2</span>(A,<span class="number">16</span>);<span class="comment">//返回的是一个地址</span></span><br><span class="line">    *<span class="built_in">max2</span>(A,<span class="number">16</span>) = <span class="number">-1</span>;<span class="comment">//将最大值修改为-1</span></span><br><span class="line">    cout &lt;&lt; <span class="built_in">max3</span>(A,<span class="number">16</span>);</span><br><span class="line">    <span class="built_in">max</span>(A,<span class="number">16</span>) = <span class="number">-1</span>;<span class="comment">//将最大值修改为-1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>可以用const限定引用</li>
<li>要及時釋放在堆中的變量的引用</li>
</ul>
<h2 id="異常處理"><a href="#異常處理" class="headerlink" title="異常處理"></a>異常處理</h2><p>C++的異常處理是一種特殊的程序機制，用於處理程序中出現的異常情況。異常可能由各種原因引起，例如除數為0、訪問超出數組範圍的元素等。異常處理能夠有效地幫助我們捕捉和處理這些異常情況，以保證程序的穩定性和可靠性。</p>
<p>例如，假設有一個名為my_div的函數，用於計算兩個數的商<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">my_div</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (y == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> std::<span class="built_in">runtime_error</span>(<span class="string">&quot;除數不能為0&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> x / y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="type">int</span> result = <span class="built_in">my_div</span>(<span class="number">10</span>, <span class="number">0</span>);</span><br><span class="line">    std::cout &lt;&lt; result &lt;&lt; std::endl;</span><br><span class="line">  &#125; <span class="built_in">catch</span> (<span class="type">const</span> std::exception&amp; e) &#123;</span><br><span class="line">    std::cerr &lt;&lt; <span class="string">&quot;錯誤：&quot;</span> &lt;&lt; e.<span class="built_in">what</span>() &lt;&lt; std::endl;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>它接受兩個整型參數x和y，並計算它們的商。如果y為0，則拋出一個異常，表示除數不能為0。</p>
<p>接下來，在main函數中通過try和catch語句來處理異常，當函數拋出一個異常時，程序將立即停止执行try語句中的代碼，並跳轉到下面的catch語句中去處理異常。</p>
<p>C++的異常處理還有一些更高級的用法。例如，可以定義自己的異常類型，並在拋出異常時傳遞額外的信息。還可以在捕捉異常時拋出新的異常，以便進一步處理。</p>
<p>例如，假設有一個名為MyException的自定義異常類型，並想要在拋出異常時傳遞額外的信息。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyException</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">explicit</span> <span class="title">MyException</span><span class="params">(<span class="type">const</span> std::string&amp; msg)</span> : message_(msg) &#123;</span>&#125;</span><br><span class="line">  <span class="function"><span class="type">const</span> std::string&amp; <span class="title">GetMessage</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> message_; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  std::string message_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">my_div</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (y == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="built_in">MyException</span>(<span class="string">&quot;除數不能為0&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> x / y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="type">int</span> result = <span class="built_in">my_div</span>(<span class="number">10</span>, <span class="number">0</span>);</span><br><span class="line">    std::cout &lt;&lt; result &lt;&lt; std::endl;</span><br><span class="line">  &#125; <span class="built_in">catch</span> (<span class="type">const</span> MyException&amp; e) &#123;</span><br><span class="line">    std::cerr &lt;&lt; <span class="string">&quot;錯誤：&quot;</span> &lt;&lt; e.<span class="built_in">GetMessage</span>() &lt;&lt; std::endl;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>main函數中捕捉到了拋出的異常。在這裡，我們通過調用MyException類型的GetMessage方法獲取傳遞的額外信息，並將它輸出到終端機。<br>捕捉到異常時拋出新的異常:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyException</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">explicit</span> <span class="title">MyException</span><span class="params">(<span class="type">const</span> std::string&amp; msg)</span> : message_(msg) &#123;</span>&#125;</span><br><span class="line">  <span class="function"><span class="type">const</span> std::string&amp; <span class="title">GetMessage</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> message_; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  std::string message_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">my_func</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="type">int</span> result = <span class="built_in">my_div</span>(<span class="number">10</span>, <span class="number">0</span>);</span><br><span class="line">    std::cout &lt;&lt; result &lt;&lt; std::endl;</span><br><span class="line">  &#125; <span class="built_in">catch</span> (<span class="type">const</span> MyException&amp; e) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="built_in">MyException</span>(<span class="string">&quot;錯誤：&quot;</span> + e.<span class="built_in">GetMessage</span>());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="type">int</span> result = <span class="built_in">my_func</span>();</span><br><span class="line">    std::cout &lt;&lt; result &lt;&lt; std::endl;</span><br><span class="line">  &#125; <span class="built_in">catch</span> (<span class="type">const</span> MyException</span><br></pre></td></tr></table></figure><br>異常处理的主要用可以預見且無法避免的錯誤，可以提高程序的Bobustness。</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="https://www.hongzixian.cn">HongZiXian</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章連結: </span><span class="post-copyright-info"><a href="https://www.hongzixian.cn/2022/04/12/C++%E6%A6%82%E8%BF%B0/">https://www.hongzixian.cn/2022/04/12/C++%E6%A6%82%E8%BF%B0/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版權聲明: </span><span class="post-copyright-info">本部落格所有文章除特別聲明外，均採用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 許可協議。轉載請註明來自 <a href="https://www.hongzixian.cn" target="_blank">King's Backyard</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E7%AD%86%E8%A8%98/">筆記</a><a class="post-meta__tags" href="/tags/C/">C++</a></div><div class="post_share"><div class="social-share" data-image="https://s2.loli.net/2022/12/08/ACt1YB2fTUVuILP.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2022/04/01/%E5%BA%AB%E5%AD%98%E7%AE%A1%E7%90%86%E7%B3%BB%E7%B5%B1(ERP)-%E9%9C%80%E6%B1%82%E8%A6%8F%E6%A0%BC%E8%AA%AA%E6%98%8E%E6%96%87%E6%A1%A3/"><img class="prev-cover" src="https://s2.loli.net/2022/12/06/dfP1S3pyCEbNJ62.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">庫存管理系統(ERP)-需求規格說明文档</div></div></a></div><div class="next-post pull-right"><a href="/2022/05/03/%E5%BA%AB%E5%AD%98%E7%AE%A1%E7%90%86%E7%B3%BB%E7%B5%B1(ERP)-%E9%AB%94%E7%B3%BB%E7%BB%93%E6%A7%8B%E6%96%87%E6%AA%94/"><img class="next-cover" src="https://s2.loli.net/2022/12/07/z3CJbWMnAHYVOZ8.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">庫存管理系統(ERP)-體系结構文檔</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相關推薦</span></div><div class="relatedPosts-list"><div><a href="/2020/03/16/CSS%20%E5%9F%BA%E6%9C%AC%E7%9F%A5%E8%AD%98%E4%B8%80%E6%96%87%E9%80%9A/" title="CSS基本知識一文通"><img class="cover" src="https://s2.loli.net/2022/12/01/LTPNlnvH8Xdx2JG.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2020-03-16</div><div class="title">CSS基本知識一文通</div></div></a></div><div><a href="/2020/03/15/HTML%E5%9F%BA%E6%9C%AC%E7%9F%A5%E8%AD%98%E4%B8%80%E6%96%87%E9%80%9F%E9%80%9A/" title="HTML基本知識一文速通"><img class="cover" src="https://s2.loli.net/2022/11/26/aGLZyQcDoKjdEgb.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2020-03-15</div><div class="title">HTML基本知識一文速通</div></div></a></div><div><a href="/2022/12/07/Web%E5%89%8D%E8%AB%AF%E6%B0%B4%E5%8D%B0%E6%96%B9%E6%A1%88/" title="Web前端水印方案"><img class="cover" src="https://s2.loli.net/2022/12/07/6D1ymZrpxqoh5e7.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-12-07</div><div class="title">Web前端水印方案</div></div></a></div></div></div><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 評論</span></div></div><div class="comment-wrap"><div><div id="twikoo-wrap"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://s2.loli.net/2022/11/22/gqkpnz3Prte8RQU.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">HongZiXian</div><div class="author-info__description"></div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">18</div></a><a href="/tags/"><div class="headline">標籤</div><div class="length-num">19</div></a><a href="/categories/"><div class="headline">分類</div><div class="length-num">5</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/a2064777923"><i class="fab fa-github"></i><span>前往我的主頁</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/a2064777923" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="/a2064777923@gmail.com" target="_blank" title="Email"><i class="fas fa-envelope"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">v2.5 加入外挂標簽 v2.4 更新導航欄置中，音樂播放插件</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目錄</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B0%A1%E4%BB%8B"><span class="toc-number">1.</span> <span class="toc-text">簡介</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A8%8B%E5%BA%8F%E8%AA%9E%E5%8F%A5"><span class="toc-number">2.</span> <span class="toc-text">程序語句</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A2%9D%E4%BB%B6%E7%B5%90%E6%A7%8B"><span class="toc-number">2.1.</span> <span class="toc-text">條件結構</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BE%AA%E7%92%B0%E7%B5%90%E6%A7%8B"><span class="toc-number">2.2.</span> <span class="toc-text">循環結構</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%91%BD%E5%90%8D%E7%A9%BA%E9%96%93"><span class="toc-number">2.3.</span> <span class="toc-text">命名空間</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%A1%A8%E9%80%B9%E5%BC%8F"><span class="toc-number">3.</span> <span class="toc-text">表逹式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E9%81%8B%E7%AE%97%E7%AC%A6"><span class="toc-number">3.1.</span> <span class="toc-text">基本運算符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B3%A6%E5%80%BC%E8%A1%A8%E9%80%B9%E5%BC%8F"><span class="toc-number">3.2.</span> <span class="toc-text">賦值表逹式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A2%9D%E4%BB%B6%E8%A1%A8%E9%80%B9%E5%BC%8F"><span class="toc-number">3.3.</span> <span class="toc-text">條件表逹式</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B8%E6%93%9A"><span class="toc-number">4.</span> <span class="toc-text">數據</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B8%E6%93%9A%E9%A1%9E%E5%9E%8B"><span class="toc-number">4.1.</span> <span class="toc-text">數據類型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8A%BD%E8%B1%A1%E6%95%B8%E6%93%9A%E9%A1%9E%E5%9E%8BADT"><span class="toc-number">4.2.</span> <span class="toc-text">抽象數據類型ADT</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#typedef%E9%97%9C%E9%8D%B5%E5%AD%97"><span class="toc-number">4.3.</span> <span class="toc-text">typedef關鍵字</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%B8%E9%87%8F"><span class="toc-number">4.4.</span> <span class="toc-text">常量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%8A%E9%87%8F"><span class="toc-number">4.5.</span> <span class="toc-text">變量</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%87%BD%E6%95%B8"><span class="toc-number">5.</span> <span class="toc-text">函數</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BD%E6%95%B8%E7%9A%84%E5%8E%9F%E5%89%87"><span class="toc-number">5.1.</span> <span class="toc-text">函數的原則</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BD%E6%95%B8%E6%A8%A1%E6%9D%BF"><span class="toc-number">5.2.</span> <span class="toc-text">函數模板</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BD%E6%95%B8%E7%B7%A8%E8%AD%AF%E9%8F%88%E6%8E%A5"><span class="toc-number">5.3.</span> <span class="toc-text">函數編譯鏈接</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%87%8D%E8%BC%89-Overloading-%E9%87%8D%E5%AF%AB-Overriding"><span class="toc-number">5.4.</span> <span class="toc-text">重載(Overloading)重寫(Overriding)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BD%E6%95%B8%E7%9A%84%E9%BB%98%E8%AA%8D%E5%8F%83%E6%95%B8"><span class="toc-number">5.5.</span> <span class="toc-text">函數的默認參數</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%96%E9%83%A8%E5%87%BD%E6%95%B8-extern"><span class="toc-number">5.6.</span> <span class="toc-text">外部函數 extern</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BD%E6%95%B8%E8%88%87%E5%85%A7%E5%AD%98"><span class="toc-number">5.7.</span> <span class="toc-text">函數與內存</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%83%E6%95%B8%E5%82%B3%E9%80%92"><span class="toc-number">5.8.</span> <span class="toc-text">參數傳递</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BD%E6%95%B8%E8%AA%BF%E7%94%A8%E9%81%8E%E7%A8%8B%E7%B8%BD%E7%B5%90"><span class="toc-number">5.9.</span> <span class="toc-text">函數調用過程總結</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%A7%E8%81%AF%E5%87%BD%E6%95%B8inline"><span class="toc-number">5.10.</span> <span class="toc-text">內聯函數inline</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BC%B8%E5%85%A5%E8%BC%B8%E5%87%BA"><span class="toc-number">6.</span> <span class="toc-text">輸入輸出</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BC%B8%E5%85%A5"><span class="toc-number">6.1.</span> <span class="toc-text">輸入</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BC%B8%E5%87%BA"><span class="toc-number">6.2.</span> <span class="toc-text">輸出</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%87%8D%E5%AE%9A%E5%90%91"><span class="toc-number">6.3.</span> <span class="toc-text">重定向</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E8%AE%80%E5%AF%AB"><span class="toc-number">6.4.</span> <span class="toc-text">文件讀寫</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8C%87%E9%87%9D%E5%92%8C%E5%BC%95%E7%94%A8"><span class="toc-number">7.</span> <span class="toc-text">指針和引用</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C"><span class="toc-number">7.1.</span> <span class="toc-text">基本操作</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%B8%E9%87%8F%E6%8C%87%E9%87%9D%E8%88%87%E6%8C%87%E9%87%9D%E5%B8%B8%E9%87%8F"><span class="toc-number">7.2.</span> <span class="toc-text">常量指針與指針常量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8C%87%E9%87%9D%E8%88%87%E5%87%BD%E6%95%B8"><span class="toc-number">7.3.</span> <span class="toc-text">指針與函數</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B8%E7%B5%84"><span class="toc-number">7.4.</span> <span class="toc-text">數組</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%9A%E7%B4%9A%E6%8C%87%E9%87%9D"><span class="toc-number">7.5.</span> <span class="toc-text">多級指針</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8B%95%E6%85%8B%E8%AE%8A%E9%87%8F"><span class="toc-number">7.6.</span> <span class="toc-text">動態變量</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%95%B0%E5%B8%B8%E8%99%95%E7%90%86"><span class="toc-number">8.</span> <span class="toc-text">異常處理</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2022/12/07/Web%E5%89%8D%E8%AB%AF%E6%B0%B4%E5%8D%B0%E6%96%B9%E6%A1%88/" title="Web前端水印方案"><img src="https://s2.loli.net/2022/12/07/6D1ymZrpxqoh5e7.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Web前端水印方案"/></a><div class="content"><a class="title" href="/2022/12/07/Web%E5%89%8D%E8%AB%AF%E6%B0%B4%E5%8D%B0%E6%96%B9%E6%A1%88/" title="Web前端水印方案">Web前端水印方案</a><time datetime="2022-12-07T06:16:07.000Z" title="發表於 2022-12-07 14:16:07">2022-12-07</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/11/24/%E5%9F%BA%E6%96%BC%E7%BD%AE%E4%BF%A1%E5%AD%B8%E7%BF%92%E7%9A%84%E8%AD%A6%E5%91%8A%E6%95%B8%E6%93%9A%E9%9B%86%E5%8E%BB%E5%99%AA%E6%8A%80%E8%A1%93/" title="基於置信學習的警告數據集去噪技術"><img src="https://s2.loli.net/2022/11/24/f9hnyvp1Y5iDmbK.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="基於置信學習的警告數據集去噪技術"/></a><div class="content"><a class="title" href="/2022/11/24/%E5%9F%BA%E6%96%BC%E7%BD%AE%E4%BF%A1%E5%AD%B8%E7%BF%92%E7%9A%84%E8%AD%A6%E5%91%8A%E6%95%B8%E6%93%9A%E9%9B%86%E5%8E%BB%E5%99%AA%E6%8A%80%E8%A1%93/" title="基於置信學習的警告數據集去噪技術">基於置信學習的警告數據集去噪技術</a><time datetime="2022-11-24T15:19:30.000Z" title="發表於 2022-11-24 23:19:30">2022-11-24</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/11/22/hexo%E4%B8%BB%E9%A2%98%E9%AD%94%E6%94%B9/" title="hexo主题魔改"><img src="https://s2.loli.net/2022/11/23/cgS1Mo89mrXuNlj.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="hexo主题魔改"/></a><div class="content"><a class="title" href="/2022/11/22/hexo%E4%B8%BB%E9%A2%98%E9%AD%94%E6%94%B9/" title="hexo主题魔改">hexo主题魔改</a><time datetime="2022-11-22T11:48:46.000Z" title="發表於 2022-11-22 19:48:46">2022-11-22</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/11/22/butterfly%E4%B8%BB%E9%A1%8C%E4%B8%80%E4%BA%9B%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95/" title="Butterfly主題一些使用方法"><img src="https://s2.loli.net/2022/11/23/cgS1Mo89mrXuNlj.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Butterfly主題一些使用方法"/></a><div class="content"><a class="title" href="/2022/11/22/butterfly%E4%B8%BB%E9%A1%8C%E4%B8%80%E4%BA%9B%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95/" title="Butterfly主題一些使用方法">Butterfly主題一些使用方法</a><time datetime="2022-11-22T11:47:56.000Z" title="發表於 2022-11-22 19:47:56">2022-11-22</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/11/22/%E7%94%A8Hexo%E5%92%8CVercel%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8D%9A%E5%AE%A2/" title="利用Hexo和Vercel搭建博客"><img src="https://s2.loli.net/2022/11/22/k8tScd6TbD9Ka5Y.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="利用Hexo和Vercel搭建博客"/></a><div class="content"><a class="title" href="/2022/11/22/%E7%94%A8Hexo%E5%92%8CVercel%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8D%9A%E5%AE%A2/" title="利用Hexo和Vercel搭建博客">利用Hexo和Vercel搭建博客</a><time datetime="2022-11-22T10:26:40.000Z" title="發表於 2022-11-22 18:26:40">2022-11-22</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url('https://s2.loli.net/2022/12/08/UVKDqt6r1GP5F7z.png')"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2022 By HongZiXian</div><div class="footer_custom_text">事穷势蹙之人，当原其初心；功成行满之士，要观其末路 -- 洪应明<p><a target="_blank" href="https://hexo.io/"><img src="https://img.shields.io/badge/Frame-Hexo-blue?style=flat&logo=hexo" title="博客框架为Hexo"></a>&nbsp;<a target="_blank" href="https://butterfly.js.org/"><img src="https://img.shields.io/badge/Theme-Butterfly-6513df?style=flat&logo=bitdefender" title="主题采用butterfly"></a>&nbsp;<a target="_blank" href="https://www.jsdelivr.com/"><img src="https://img.shields.io/badge/CDN-jsDelivr-orange?style=flat&logo=jsDelivr" title="本站使用JsDelivr为静态资源提供CDN加速"></a> &nbsp;<a target="_blank" href="https://vercel.com/ "><img src="https://img.shields.io/badge/Hosted-Vervel-brightgreen?style=flat&logo=Vercel" title="本站采用双线部署，默认线路托管于Vercel"></a>&nbsp;<a target="_blank" href="https://vercel.com/ "><img src="https://img.shields.io/badge/Hosted-Coding-0cedbe?style=flat&logo=Codio" title="本站采用双线部署，联通线路托管于Coding"></a>&nbsp;<a target="_blank" href="https://github.com/a2064777923/a2064777923.github.io"><img src="https://img.shields.io/badge/Source-Github-d021d6?style=flat&logo=GitHub" title="本站项目由Gtihub托管"></a>&nbsp;<a target="_blank" href="http://creativecommons.org/licenses/by-nc-sa/4.0/"><img src="https://img.shields.io/badge/Copyright-BY--NC--SA%204.0-d42328?style=flat&logo=Claris" title="本站采用知识共享署名-非商业性使用-相同方式共享4.0国际许可协议进行许可"></a></p></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="閱讀模式"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="簡繁轉換">繁</button><button id="darkmode" type="button" title="淺色和深色模式轉換"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="單欄和雙欄切換"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="設定"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目錄"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直達評論"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到頂部"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜尋</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  資料庫載入中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜尋文章" type="text"/></div></div><hr/><div id="local-search-results"></div></div></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><script src="/js/search/local-search.js"></script><div class="js-pjax"><script>(()=>{
  const init = () => {
    twikoo.init(Object.assign({
      el: '#twikoo-wrap',
      envId: 'https://twikoo-system.hongzixian.cn/',
      region: '',
      onCommentLoaded: function () {
        btf.loadLightbox(document.querySelectorAll('#twikoo .tk-content img:not(.tk-owo-emotion)'))
      }
    }, null))
  }

  const getCount = () => {
    const countELement = document.getElementById('twikoo-count')
    if(!countELement) return
    twikoo.getCommentsCount({
      envId: 'https://twikoo-system.hongzixian.cn/',
      region: '',
      urls: [window.location.pathname],
      includeReply: false
    }).then(function (res) {
      countELement.innerText = res[0].count
    }).catch(function (err) {
      console.error(err);
    });
  }

  const runFn = () => {
    init()
    
  }

  const loadTwikoo = () => {
    if (typeof twikoo === 'object') {
      setTimeout(runFn,0)
      return
    } 
    getScript('https://cdn.jsdelivr.net/npm/twikoo/dist/twikoo.all.min.js').then(runFn)
  }

  if ('Twikoo' === 'Twikoo' || !true) {
    if (true) btf.loadComment(document.getElementById('twikoo-wrap'), loadTwikoo)
    else loadTwikoo()
  } else {
    window.loadOtherComment = () => {
      loadTwikoo()
    }
  }
})()</script></div><div class="aplayer no-destroy" data-id="2459826936" data-server="netease" data-type="playlist" data-fixed="true" data-autoplay="true"> </div><script id="click-heart" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/click-heart.min.js" async="async" mobile="false"></script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/metingjs/dist/Meting.min.js"></script><script src="https://cdn.jsdelivr.net/npm/pjax/pjax.min.js"></script><script>let pjaxSelectors = ["head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]

var pjax = new Pjax({
  elements: 'a:not([target="_blank"])',
  selectors: pjaxSelectors,
  cacheBust: false,
  analytics: false,
  scrollRestoration: false
})

document.addEventListener('pjax:send', function () {

  // removeEventListener scroll 
  window.tocScrollFn && window.removeEventListener('scroll', window.tocScrollFn)
  window.scrollCollect && window.removeEventListener('scroll', scrollCollect)

  document.getElementById('rightside').style.cssText = "opacity: ''; transform: ''"
  
  if (window.aplayers) {
    for (let i = 0; i < window.aplayers.length; i++) {
      if (!window.aplayers[i].options.fixed) {
        window.aplayers[i].destroy()
      }
    }
  }

  typeof typed === 'object' && typed.destroy()

  //reset readmode
  const $bodyClassList = document.body.classList
  $bodyClassList.contains('read-mode') && $bodyClassList.remove('read-mode')

  typeof disqusjs === 'object' && disqusjs.destroy()
})

document.addEventListener('pjax:complete', function () {
  window.refreshFn()

  document.querySelectorAll('script[data-pjax]').forEach(item => {
    const newScript = document.createElement('script')
    const content = item.text || item.textContent || item.innerHTML || ""
    Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
    newScript.appendChild(document.createTextNode(content))
    item.parentNode.replaceChild(newScript, item)
  })

  GLOBAL_CONFIG.islazyload && window.lazyLoadInstance.update()

  typeof chatBtnFn === 'function' && chatBtnFn()
  typeof panguInit === 'function' && panguInit()

  // google analytics
  typeof gtag === 'function' && gtag('config', '', {'page_path': window.location.pathname});

  // baidu analytics
  typeof _hmt === 'object' && _hmt.push(['_trackPageview',window.location.pathname]);

  typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()

  // prismjs
  typeof Prism === 'object' && Prism.highlightAll()
})

document.addEventListener('pjax:error', (e) => {
  if (e.request.status === 404) {
    pjax.loadUrl('/404.html')
  }
})</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div><!-- hexo injector body_end start --><script async src="//at.alicdn.com/t/font_2032782_8d5kxvn09md.js"></script><script data-pjax>
    function butterfly_categories_card_injector_config(){
      var parent_div_git = document.getElementById('recent-posts');
      var item_html = '<style>li.categoryBar-list-item{width:32.3%;}.categoryBar-list{max-height: 380px;overflow:auto;}.categoryBar-list::-webkit-scrollbar{width:0!important}@media screen and (max-width: 650px){.categoryBar-list{max-height: 320px;}}</style><div class="recent-post-item" style="height:auto;width:100%;padding:0px;"><div id="categoryBar"><ul class="categoryBar-list"><li class="categoryBar-list-item" style="background:url(https://s2.loli.net/2022/11/26/9YKJdwjMPZkNuC2.jpg);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/C/&quot;);" href="javascript:void(0);">C++</a><span class="categoryBar-list-count">1</span><span class="categoryBar-list-descr">web前端</span></li><li class="categoryBar-list-item" style="background:url(https://s2.loli.net/2022/11/22/KpEUIoJz1nrmL6P.jpg);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/web前端/&quot;);" href="javascript:void(0);">web前端</a><span class="categoryBar-list-count">3</span><span class="categoryBar-list-descr">博客相關</span></li><li class="categoryBar-list-item" style="background:url(https://s2.loli.net/2022/11/24/jwF6iMUQARpGISo.jpg);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/博客相關/&quot;);" href="javascript:void(0);">博客相關</a><span class="categoryBar-list-count">4</span><span class="categoryBar-list-descr">煩人作業</span></li><li class="categoryBar-list-item" style="background:url(https://s2.loli.net/2022/12/08/yv5DLReTwmUEMOx.jpg);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/煩人作業/&quot;);" href="javascript:void(0);">煩人作業</a><span class="categoryBar-list-count">8</span><span class="categoryBar-list-descr">C++</span></li><li class="categoryBar-list-item" style="background:url(https://s2.loli.net/2022/11/29/MlsVrg46WYSGhXd.jpg);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/操作系統/&quot;);" href="javascript:void(0);">操作系統</a><span class="categoryBar-list-count">1</span><span class="categoryBar-list-descr">操作系統</span></li></ul></div></div>';
      console.log('已挂载butterfly_categories_card')
      parent_div_git.insertAdjacentHTML("afterbegin",item_html)
      }
    if( document.getElementById('recent-posts') && (location.pathname ==='/'|| '/' ==='all')){
    butterfly_categories_card_injector_config()
    }
  </script><div class="js-pjax"><script async="async">var arr = document.getElementsByClassName('recent-post-item');
for(var i = 0;i<arr.length;i++){
    arr[i].classList.add('wow');
    arr[i].classList.add('animate__zoomIn');
    arr[i].setAttribute('data-wow-duration', '2s');
    arr[i].setAttribute('data-wow-delay', '1s');
    arr[i].setAttribute('data-wow-offset', '100');
    arr[i].setAttribute('data-wow-iteration', '1');
  }</script><script async="async">var arr = document.getElementsByClassName('card-widget');
for(var i = 0;i<arr.length;i++){
    arr[i].classList.add('wow');
    arr[i].classList.add('animate__zoomIn');
    arr[i].setAttribute('data-wow-duration', '');
    arr[i].setAttribute('data-wow-delay', '');
    arr[i].setAttribute('data-wow-offset', '');
    arr[i].setAttribute('data-wow-iteration', '');
  }</script></div><script defer src="https://npm.elemecdn.com/hexo-butterfly-wowjs/lib/wow.min.js"></script><script defer src="https://npm.elemecdn.com/hexo-butterfly-wowjs/lib/wow_init.js"></script><!-- hexo injector body_end end --></body></html>